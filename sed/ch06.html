<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Глава 6. info sed. (русский перевод).</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="index.html" title="Краткий учебник по sed."><link rel="prev" href="ch05s03.html" title="AABS"><link rel="next" href="ch06s02.html" title="Программирование в sed."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Глава 6. info sed. (русский перевод).</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s03.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06s02.html">След.</a></td></tr></table><hr></div><div class="chapter" title="Глава 6. info sed. (русский перевод)."><div class="titlepage"><div><div><h2 class="title"><a name="id2531039"></a>Глава 6. <a name="ch06"></a>info sed. (русский перевод).</h2></div></div></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="section"><a href="ch06.html#id2531048">info sed Потоковый редактор.</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#id2531054">Начало</a></span></dt><dt><span class="section"><a href="ch06.html#id2531819">Ограничения sed.</a></span></dt><dt><span class="section"><a href="ch06.html#id2532390">Ключи командной строки.</a></span></dt></dl></dd><dt><span class="section"><a href="ch06s02.html">Программирование в sed.</a></span></dt><dd><dl><dt><span class="section"><a href="ch06s02.html#id2532927">Вступление.</a></span></dt><dt><span class="section"><a href="ch06s02.html#id2532980">Выбор строк, которые редактирует `sed' (адресация).</a></span></dt><dt><span class="section"><a href="ch06s02.html#id2533524">Обзор синтаксиса регулярных выражений.</a></span></dt><dt><span class="section"><a href="ch06s02.html#id2534990">Как `sed' буферизирует данные?</a></span></dt></dl></dd><dt><span class="section"><a href="ch06s03.html">Команды sed</a></span></dt><dd><dl><dt><span class="section"><a href="ch06s03.html#id2535102">Основные команды(#,q,d,p,n,{},s).</a></span></dt><dt><span class="section"><a href="ch06s03.html#id2536140">Другие команды(y,a,i,c,=,l,r,w,D,N,P,h,H,g,G,x).</a></span></dt><dt><span class="section"><a href="ch06s03.html#id2537099">Команды для <span class="command"><strong>sed</strong></span> гуру(:,b,t).</a></span></dt><dt><span class="section"><a href="ch06s03.html#id2537420">Команды специфичные для GNU `sed'(e,L,Q,R,T,v,W)</a></span></dt><dt><span class="section"><a href="ch06s03.html#id2537809">Команда z</a></span></dt></dl></dd><dt><span class="section"><a href="ch06s04.html">GNU Расширения регулярных выражений.</a></span></dt><dd><dl><dt><span class="section"><a href="ch06s04.html#id2537929">Список спец-символов.</a></span></dt></dl></dd></dl></div><div class="section" title="info sed Потоковый редактор."><div class="titlepage"><div><div><h3 class="title"><a name="id2531048"></a>info sed Потоковый редактор.</h3></div></div></div><div class="section" title="Начало"><div class="titlepage"><div><div><h4 class="title"><a name="id2531054"></a>Начало</h4></div></div></div><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>Перевод drBatty</div><p>
				Документация к версии 4.0.9 GNU 'sed', потоковому редактору. Втр 25 Авг 2009 17:02:38
			</p><p>				
				Исправлено для версии 4.2. Сбт Июн  5 10:58:00 MSD 2010
			</p><p>
				<span class="command"><strong>sed</strong></span> это потоковый редактор. Потоковый редактор используется для базовых преобразований текста из входного потока(из файла, или из конвейера). Отличие <span class="command"><strong>sed</strong></span> от других редакторов заключается в том, что в других редакторах мы:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">загружаем текст</li><li class="listitem">редактируем нужные строки</li><li class="listitem">сохраняем результат</li></ol></div><p>
				В отличие от них, в <span class="command"><strong>sed</strong></span> п2 и п1 идут в обратном порядке, т.е.
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Мы пишем скрипт на особом <span class="quote">&#171;<span class="quote">языке <span class="command"><strong>sed</strong></span></span>&#187;</span>, в котором написано КАК надо редактировать текст.
					</li><li class="listitem"><span class="command"><strong>sed</strong></span> выполняет наш скрипт над данным текстом:
						<div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><span class="command"><strong>sed</strong></span> загружает первую строку из входного потока.
							</li><li class="listitem"><span class="command"><strong>sed</strong></span> выполняет написанный нами скрипт для загруженной строки.
							</li><li class="listitem"><span class="command"><strong>sed</strong></span> выводит строку в выходной поток.
							</li><li class="listitem">
								пункты 2.a, 2.b, и 2.c выполняются для всех строк входного потока,
							</li><li class="listitem">
								...кроме случая, когда скрипт указывает иное(например в пункте 2.b возможен случай, когда загрузится следующая строка, и потому, пункт 2.a выполнится не для всех строк текста; кроме того, скрипт в любой момент может завершить работу, и прочее...)
							</li></ol></div></li></ol></div><p>
			</p><p>
					Конечно, обычные задачи редактирования текста выполнять с помощью <span class="command"><strong>sed</strong></span> жутко неудобно (хотя и возможно), по той простой причине, что редактировать текст необходимо ДО его загрузки (текста может и не существовать в тот момент, когда мы его редактируем). Однако, с другой стороны, редактирование может происходить в автоматическом режиме и|или пользователем, который слабо понимает, что-же он собственно делает ;-) Кроме того, входные и выходные данные практически для всех команд Linux являются текстами, а значит, мы можем собирать почти любые команды в "сверх-конвейеры", используя в качестве "цемента" команду <span class="command"><strong>sed</strong></span>.
			</p><p>
				В качестве языка программирования в <span class="command"><strong>sed</strong></span> применяется достаточно простой специальный язык, в основном заимствованный из старинного редактора <span class="command"><strong>ed</strong></span>. Все команды записываются одним символом, при этом большие и малые буквы различаются(<span class="command"><strong>n</strong></span> и <span class="command"><strong>N</strong></span> это разные команды). В <span class="command"><strong>sed</strong></span> имеется всего две переменные:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						область редактирования. (далее для краткости <span class="emphasis"><em>буфер</em></span>), в начале каждого цикла именно в него загружается текущая строка, и обычно в него помещаются результаты работы <span class="command"><strong>sed</strong></span>-скрипта. Если не указано иное, в конце каждого цикла обработки строки, содержимое буфера выводится в выходной поток.
					</li><li class="listitem">
						область удержания, hold space, далее для краткости <span class="command"><strong>буфер2</strong></span>. В буфер2 можно записать(или добавить) буфер, для сохранения его значения между циклами обработки строк. К примеру, в нём можно собрать одну большую строку, из заданного количества исходных строк текста. Конечно возможны и более сложные (и более полезные!) применения буфера2, они ограничиваются только вашей фантазией.
					</li></ol></div><p>
			</p><p>
				В языке <span class="command"><strong>sed</strong></span> доступны операции условных и безусловных переходов, операции с файлами, а так-же вызовы внешних команд(<span class="command"><strong>shell</strong></span>).
			</p><p>
				Доказано, что на языке <span class="command"><strong>sed</strong></span> теоретически можно написать ЛЮБУЮ программу, хотя конечно для выполнения многих задач лучше использовать другие языки. Впрочем, для задач обработки текстов, <span class="command"><strong>sed</strong></span> более чем достаточно, что позволяет мне отказаться от применения более сложных языков, таких как <span class="command"><strong>perl</strong></span> или <span class="command"><strong>gawk</strong></span>.
			</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3><p>
					Следует помнить, что хотя <span class="command"><strong>sed</strong></span> - интерпретируемый ЯП, скорость обработки скриптов во много раз выше чем у других языков (это связанно в основном с тем, что язык <span class="command"><strong>sed</strong></span> очень прост, и во многих случаях даже примитивен, интерпретатору не нужно долго думать о назначении каждой команды, т.к. команды всегда размером в 1 символ, кроме того, не надо искать по таблицам переменные - их всего 2, и любая команда жёстко привязана к своим переменным). Хотя сами скрипты <span class="command"><strong>sed</strong></span> и интерпретируются, но входящие в них регулярные выражения компилируются(собираются), это позволяет использовать одно и то-же выражение многократно, без повторения его разбора в каждом цикле.
				</p><p>
					В отличие от более сложных языков включающих регулярные выражения(<span class="command"><strong>perl</strong></span>, <span class="command"><strong>php</strong></span>, etc...), в <span class="command"><strong>sed</strong></span> нет регулировки "жадности" выражений - регулярные выражения в <span class="command"><strong>sed</strong></span> всегда жадные. С одной стороны, это неудобно для кодера, так-как ограничивает его свободу построения регулярных выражений, с другой стороны, мне ещё ни разу не встречалось выражение, которое нельзя было-бы переписать для <span class="command"><strong>sed</strong></span>, а разных выражений я написал довольно много... Конечно, я допускаю, что можно придумать такое выражение, и возможно даже задачу, в котором оно необходимо, однако на практике такого мне не попадалось. Не отключаемая жадность выражений в <span class="command"><strong>sed</strong></span> позволяет добиться более высокой скорости, чем в других языках (ценой несколько более высокого расхода мозгового вещества кодера :-) ).
				</p><p>
					Простота языка <span class="command"><strong>sed</strong></span> позволяет использовать его даже без всякого изучения! Если вы понимаете, что такое regexp вы можете писать скрипты для <span class="command"><strong>sed</strong></span> сразу, просто просмотрев по диагонали man sed. Эта простота сыграла с <span class="command"><strong>sed</strong></span> злую шутку: большинство пользователей полагают, что <span class="command"><strong>sed</strong></span> это всего-лишь тупой фильтр, способный заменить в тексте одно слово на другое, и не более. Это не так - несмотря на многие ограничения <span class="command"><strong>sed</strong></span>, это действительно мощный ЯП, позволяющий во многих случаях решить задачу самым быстрым способом. (быстрым как по времени выполнения скрипта, так и по времени его разработки). 
				</p><p>
					Во многих(если не в большинстве) случаях, применение ЯП низкого уровня (вроде C) не даёт существенного повышения быстродействия, за то приводит к большим сложностям при разработке, кроме того, конечному пользователю в большинстве случаев придётся ещё и пересобрать программу для своей системы (это в лучшем случае!), применение-же других ЯП высокого уровня часто не оправдано (хеш таблицы на 100 переменных и связанные списки - отличная штука, вот только далеко не всегда это надо). 
				</p><p>
					Кроме того, применяя более мощные интерпретируемые языки (вроде <span class="command"><strong>perl</strong></span>'а) мы сильно теряем в скорости. Если-же нам, для выполнения нашей задачи, действительно нужны сложные структуры данных (например базы данных), то встроенные в языки высокого уровня нам мало помогут - они оптимизированы для некоторого класса задач, и обычно нам не сильно подходят, сменить их нет никакой возможности - если в <span class="command"><strong>php</strong></span> массивы являются hash таблицами - то это так и останется, надо нам это или нет, поменять структуру массива на, к примеру, 2-3 дерево, или даже на простейший линейный массив нет никакой возможности. 
				</p><p>
					То, что в <span class="command"><strong>sed</strong></span> нету никаких структур данных и даже никакой возможности их организации является скорее достоинством - я с лёгкостью прикручивал к <span class="command"><strong>sed</strong></span>-скрипту работу с MySQL базой данных, это даже проще, чем интегрировать БД в <span class="command"><strong>php</strong></span>, я уж не говорю о C++. А сравнивать скорость и мощность MySQL со встроенными массивами какого-нибудь <span class="command"><strong>perl</strong></span>'а просто глупо.
				</p><p>
					Дальнейший текст представляет собой слегка обработанный перевод info sed. Обработка связанна с тем, что я говорю и пишу не по английски, потому я подчеркну некоторые моменты, которые слабо волновали англоговорящих кодеров - им проще, каждая их буква занимает диапазон [a-zA-Z], и всегда укладывается в один байт, и более того! В этом байте старший бит всегда равен 0. Для русского языка это, к сожалению, не так: в русском языке применяется множество кодировок, причём почти все они используются на практике. Мало того, в кодировках UTF* одна русская буква занимает два байта - в этом случае работа утилиты <span class="command"><strong>sed</strong></span> существенно усложняется. К счастью, в современных версиях(уже лет 10 как) эти различия и особенности локализаций учтены, и потому утилита <span class="command"><strong>sed</strong></span> прекрасно справляется с обработкой в т.ч. и текстов на русском языке, хотя при работе с ними нужно учитывать некоторые тонкие моменты.
				</p><p>
					Кроме того, я ещё и проверял примеры на практике, причём позволил себе некоторые из них незначительно изменить. Например, лично я не люблю базовые регулярные выражения, и предпочитаю расширенные. Спор о том, какие из них лучше похож на спор о том, с какой стороны нужно разбивать яйцо :-) Мне кажется, что удобнее расширенные, т.к. мне попадаются выражения, которые короче записываются именно как ERE, хотя в вашем случае это может быть и не так. 
				</p><p>
					В оригинале, авторы используют базовые RE, я-же часто буду использовать ERE, к тому-же, в примерах, это более наглядно. В любом случае, разница между базовыми и расширенными выражениями всего-лишь в форме записи, не смотря на название, расширенные regexp'ы не дают никаких новых возможностей по сравнению с базовыми (скорее наоборот - могут быть непереносимыми, и требуют дополнительных опций(см. <code class="option">опцию -r</code>)). 
				</p><p>
					Возможно, ERE в чём-то и полезны, например отучают от привычки некоторых <span class="command"><strong>sed</strong></span>-гуру писать <span class="quote">&#171;<span class="quote">*</span>&#187;</span>, там, где по смыслу положено писать <span class="quote">&#171;<span class="quote">\+</span>&#187;</span> (в ERE всё равно, <span class="quote">&#171;<span class="quote">*</span>&#187;</span> или <span class="quote">&#171;<span class="quote">+</span>&#187;</span>, в обычных RE плюс ещё надо за экранировать. Понятно, что <span class="command"><strong>sed</strong></span> скрипты пишут только ленивые люди, потому им лень ставить \. Не ленивые правят свои тексты в блокноте, и про <span class="command"><strong>sed</strong></span> не в курсе).
				</p></div></div><div class="section" title="Ограничения sed."><div class="titlepage"><div><div><h4 class="title"><a name="id2531819"></a>Ограничения sed.</h4></div></div></div><p>
				У sed существуют сильные ограничения, о них надо всегда помнить:
			</p><p>
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Утилита sed предназначена для работы с текстом, не следует использовать её для работы с двоичными данными. Если-же вам всё-таки это нужно, то вам придётся решать 3 проблемы:
						<div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								В каждом цикле, sed загружает 1 строку в оперативную память компьютера, строкой в sed считается последовательность любых байтов до символа <span class="quote">&#171;<span class="quote">\n</span>&#187;</span> (включительно) в текстах строки всегда имеют небольшую длину (обычно меньше 100 байтов), и с учётом этого факта, и производилось оптимизация кода <span class="command"><strong>sed</strong></span>.
								<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
									Текущая версия sed (4.2, 2009й год) выделяет 50 байтов для строки. Если строка не влезает в 50 байтов, то область памяти удваивается. Это - не самое быстрое действие. Потому тексты в которых строки не длиннее 50 байт обрабатываются быстрее всего. Несколько медленнее обрабатываются тексты, в которых строки хоть и больше 50 байт, но не слишком длинные, к примеру тексты со строками не более 256 байт.
								</div>
								Попытка обработать текст, в котором встречались строки размером в десятки мегабайт привела к тому, что сначала потратилась вся память (я экспериментировал на старом компьютере, тут памяти всего 32Мб, и 60Мб свопа), затем заполнился весь своп (в этот момент всё жутко затормозилось), а затем ОС убила саму sed, и ещё плеер, который играл в этот момент музыку из mp3... Вы можете сказать - "У меня не такой древний комп!", ну и что? На более новых компах не только память больше, но и файлы длиннее... Что поделать, команда <span class="command"><strong>find /</strong></span> занимает примерно одинаковое время, что на этой рухляди в 133+MHz, что на моём сервере 3000MHz а именно - дохрена времени...
							</li><li class="listitem"><a name="non_sym"></a><p>
									Многие выражения будут работать совсем не так, как ожидается, рассмотрим например одно из самых простых (и часто употребляемых) RE как ".*", предполагается, что это RE совпадает с любым количеством любых символов, т.к. sed обрабатывает символы по строкам, то ожидается, что ".*" совпадёт с любой строкой, причём целиком. 
								</p><p>
									Это верно, но только для СИМВОЛОВ. Оказывается, не все байты являются символами, я сам с удивлением узнал, что некоторые байты sed считает НЕСИМВОЛАМИ! Поэтому, команда "s/.*//" вовсе НЕ очищает любую строку, она работает не так, как ожидается: стираются только первые СИМВОЛЫ, до первого НЕСИМВОЛА, и этот "хвост" начинающийся с первого НЕСИМВОЛА так и остаётся в строке. Какие байты считаются СИМВОЛАМИ, а какие НЕСИМВОЛАМИ зависит от применяемой кодировки.
								</p><p>
									Про несимволы и сложности с ними см. <a class="link" href="ch02s04.html#bugs_utf">также</a>.
								</p></li><li class="listitem"><p>
								Регулярное выражение "/../" безусловно полностью совпадает с любыми строками из двух символов, и частично совпадает со строками длиннее 2х символов ("частично совпадает" в данном случае значит, что совпадает, но ещё остаётся некоторые символы). 
								</p><p>
									Но кто вам сказал, что это RE совпадает с любыми двумя байтами? Кроме того (как я уже отметил в пункте b), что некоторые байты не являются СИМВОЛАМИ, есть ещё один момент - символ вовсе не обязательно содержит ровно 1 байт. В русском языке, в UTF-8 буквы размером 2 байта, а в китайском - даже 5!
								</p></li></ol></div><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
							Учитывая всё вышесказанное, для работы с двоичными данными необходимо прежде всего отключить локализацию: установить переменные LC_*, а так-же LANG в значение "C".
						</div></li><li class="listitem">
						То, что на всё про всё нам дано всего 2 переменных сильно ограничивает полёт фантазии - слишком сложные алгоритмы не получится реализовать sed скриптом - для этого есть другие языки. Не слишком удачно реализованы команды условных переходов, они позволяют кодировать только самые простые ветвления и циклы. Впрочем и с этим можно многое сделать - мне удавалось создать sed-скрипты с поиском по словарю, с реализацией стека, и даже скрипт, который работает как счётчик(правда в двоичной системе)(см сл. пункт).
					</li><li class="listitem"><span class="command"><strong>sed</strong></span> не умеет считать. Вообще. Это наверное единственный ЯП, в котором нет арифметики. Если вам понадобились вычисления - готовьтесь подключать внешние утилиты. То, что я смог реализовать счётчик средствами <span class="command"><strong>sed</strong></span> - исключение, которое только подтверждает правило. Даже номера строк утилите <span class="command"><strong>sed</strong></span> не по зубам :-( Эти номера могут быть использованы только в двух случаях:
						<div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								Для адресации (ниже представлены примеры и описание).
							</li><li class="listitem">
								можно ещё вывести номер строки в выходной поток, жаль что нельзя в буфер. Даже для того, что-бы просто записать перед каждой строкой её номер (вроде <span class="command"><strong>cat</strong></span><code class="option">-n</code>) приходится выводить номера строк одной командой <span class="command"><strong>sed</strong></span>, а потом, ловить номера и строки другой <span class="command"><strong>sed</strong></span>, которая их и склеивает, вроде этого:
								<pre class="screen">$ sed '=' Test.txt | sed 'N; s/\n/ /'"</pre></li></ol></div>
						Впрочем, это всё можно обойти - во первых используя конвейер, как в прошлом примере, во вторых можно вызвать средствами sed специализированные утилиты, для обработки ваших чисел. Конечно, тут сложно контролировать возникновение ошибок, но их просто избежать, если заранее, средствами самой sed, проверить входные(для внешней команды) данные. Например в ERE
						<pre class="programlisting">/[0-9]{1,3}/</pre>
						нельзя впихнуть ничего, кроме десятичного положительного целого в диапазоне 0...999; а в ERE
						<pre class="programlisting">/[[:xdigit:]]{32}/</pre>
						может войти только MD4/5 хеш, причём,хотя для самого хеша и допустимы другие шаблоны(например под мой не подходит допустимый хеш "Ac46"), но все другие значения сигнализируют о ошибке: их никогда не будет от программ вычисления этих хешей, а с другой стороны, сомневаюсь, что программы обработки хешей поймут такой "нестандарт"...
					</li><li class="listitem">
						Следует учитывать, что sed это всё-таки интерпретатор - скрипт будет выполнятся для каждой строки. Если действия в скрипте сложные, то попробуйте вынести неизменную часть в начало скрипта, в блок с адресом 1, тогда он будет выполнятся только для первой строки. Если это невозможно - оформите это отдельным скриптом (необязательно sed-скриптом, или даже вообще не скриптом), и передайте sed перед текстом. Если и это не получается - стОит подумать о смене языка :( Не забывайте, что современные компилирующие ЯП (точнее, современные компиляторы) сами выносят неизменные части из циклов, во многих случаях, даже эффективнее чем это сделал-бы программист(что поделать, программист не знает, и не может знать возможностей и ограничений железа и ОС, под которыми будет работать его программа).
						<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
							В исходниках sed есть и компилятор. Однако, думаю что для 90% применений его использование не имеет смысла: наибольшая нагрузка приходится на чтение файлов и на регулярные выражения. Потому компиляция самого sed-скрипта не приведёт ни к какому выигрышу по производительности. Впрочем - вы можете попробовать...
							<div class="warning" title="Внимание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Внимание</h3>
								Кстати, это решит многие проблемы безопасности - например вы можете установить атрибуты <span class="quote">&#171;<span class="quote">скрипта</span>&#187;</span> как 4711, что позволит юзерам ТОЛЬКО запускать эту программу, причём она будет работать с правами владельца, например рута, а юзеры не смогут не только изменить эту программу, но даже прочитать её.
							</div></div></li><li class="listitem">
						Сам принцип работы sed предполагает, что мы ТОЧНО знаем ЧТО делать, но у нас нет того С ЧЕМ мы будем это делать (часто того, С ЧЕМ будет работать sed вообще не существует). Если ситуация противоположная (например мы решили исправить программу на C, но сами ТОЧНО ещё не знаем как - надо посмотреть как она реализована, и немного(или много) её подправить) тогда использование sed - плохая идея. В этом случае найдите себе хороший текстовый редактор.
					</li><li class="listitem">
						Учтите, для многих задач уже существуют готовые модули для некоторых языков. Если для вашей задачи уже есть нужный модуль на perl'е, может есть смысл писать всё на perl?
					</li><li class="listitem">
						Наконец, команду sed большинство не понимает, а стало-быть - боятся и не любят :-( Если в вашем скрипте встретилось что-либо сложнее, чем "sed 's/XXX/YYY/'" - будьте готовы к вопросам и непониманию... С другой стороны, в Linux намного чаще приходится править чужие скрипты, чем писать свои, а в них часто встречаются довольно хитрые конструкции, в т.ч. и с sed, потому, разобраться с sed придётся, нравится вам это, или нет... К счастью, научится sed - как научится кататься на велосипеде: вы никогда уже не разучитесь. Это не WinAPI, в котором имя нужной функции помнишь всего 5 минут после изучения MSDN. (Для тех кто не в курсе: в MSDN описаны тысячи разных и необходимых функций, при этом длинна их имён составляет 10-20 букв, запомнить их практически невозможно. В sed всего 3 десятка команд, это в состоянии вызубрить даже законченный склеротик).
					</li></ol></div><p>
			</p><p>
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Далее идут примеры, для многих из них нужен входной файл. Примеры проверенные, и они работают, однако, если запускать некоторые из них, вы получите просто приглашение: Что вы хотите - это всё-таки редактор - дайте же что-нибудь отредактировать! Ну хотя-бы
					<pre class="screen">$ seq 1 10 &gt;num.txt</pre></div><p>
			</p></div><div class="section" title="Ключи командной строки."><div class="titlepage"><div><div><h4 class="title"><a name="id2532390"></a>Ключи командной строки.</h4></div></div></div><a name="info_oi"></a><p>
				<span class="command"><strong>sed</strong></span> может использоваться со следующими ключами командной строки:
				</p><div class="variablelist"><dl><dt><span class="term"><code class="option">`-V' `--version'</code></span></dt><dd>Вывод версии, информации о копирайте, и выход.</dd><dt><span class="term"><code class="option">`-h' `--help'</code></span></dt><dd>Вывод краткой справки о ключах командной строки, и выход.</dd><dt><span class="term"><code class="option">`-n' `--quiet' `--silent'</code></span></dt><dd>По умолчанию, <span class="command"><strong>sed</strong></span> выводит обработанный буфер для каждой строки, при использовании этой опции вывод подавляется, кроме явного указания (команды <span class="command"><strong>p</strong></span>; <span class="command"><strong>s///p</strong></span>; <span class="command"><strong>w</strong></span> /dev/stdout ).</dd><dt><span class="term"><code class="option">`-i[<span class="emphasis"><em>SUFFIX</em></span>]' `--in-place[=<span class="emphasis"><em>SUFFIX</em></span>]'</code></span></dt><dd><p>
								Эта опция используется для редактирования файла "на месте", т.е. вместо проталкивания файла через фильтр, он редактируется как в обычных текстовых редакторах. GNU sed создаёт временный файл, в который выводит stdout, после чего исходный файл удаляется, а на его место копируется созданный временный(если не задан <em class="replaceable"><code>SUFFIX</code></em>, если он задан, то старый файл не удаляется, а переименовывается в ${OLD_NAME}<span class="emphasis"><em>SUFFIX</em></span>). Имеется следующее расширение: если в <span class="emphasis"><em>SUFFIX</em></span> нет символов *, то <span class="emphasis"><em>SUFFIX</em></span> прибавляется к концу имени файла, иначе, * заменяется на имя исходного файла. Например:
								</p><pre class="screen">$ sed '' test.txt -ix/*~</pre><p>
								Эта команда редактирует файл test.txt, а так-же сохраняет исходную копию в каталоге x, под именем test.txt~.
								</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
									Если каталога x не существует, то исходная копия нигде не сохранится, и никаких сообщений об ошибке не будет!
								</div><p>
							</p><p>
								</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
									Подробности реализации: моя версия(4.0.9) создаёт временный файл в том-же каталоге, где лежит исходный (под именем sed??????, где ?????? - шесть уникальных символов), если такой файл создать невозможно, sed прерывает работу с сообщением об ошибке. После окончания редактирования, sed переименовывает исходный файл в соответствии с шаблоном SUFFIX, либо уничтожает исходный файл, если SUFFIX не задан, или создание невозможно. Если создание временного файла невозможно, то работа sed прерывается с ошибкой, при этом, никаких действий не совершается.
								</div><p>
								</p><div class="warning" title="Внимание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Внимание</h3><p>
										Следует учитывать, что с <code class="option">опцией -i</code> возможно <span class="quote">&#171;<span class="quote">редактирование</span>&#187;</span> даже файлов, у которых сброшено право модификации. Дело в том, что мы вовсе <span class="emphasis"><em>не редактируем</em></span> файл, мы создаём новый, а потом переименовываем его так, что-бы он стал старым. При этом старая копия уничтожается, или переименовывается (при использовании <span class="emphasis"><em>SUFFIX'а</em></span>). Такое поведение очень удобно если вы - злоумышленник, и вам требуется подчистить следы своего пребывания в чужой системе (при этом не забудьте установить атрибут s на старом файле, это приведёт к тому, что старая копия будет удалена без всякой возможности восстановления). Во всех других случаях, такое поведение представляет собой серьёзную брешь в безопасности нашей системы...
									</p><p>
										Подробнее об этом "баге" мозжно посмотреть <a class="link" href="ch02s04.html#bugs_i">здесь</a>.
									</p></div><p>
							</p><p>
								Эта опция включает опцию <code class="option">-s</code> (см. ниже).
							</p></dd><dt><span class="term"><code class="option">`-l <span class="emphasis"><em>N</em></span>' `--line-length=<span class="emphasis"><em>N</em></span>'</code></span></dt><dd>Установка длинны для принудительной разбивки строк командой 'l'. Если <span class="emphasis"><em>N</em></span> равно 0(нулю), строки никогда не разбиваются, если ключ -l не задан, Строки разбиваются по 70 символов.</dd><dt><span class="term"><code class="option">`-r' `--regexp-extended'</code></span></dt><dd>
							Использование расширенных регулярных выражений (extended regular expressions, <span class="emphasis"><em>ERE</em></span>). Расширенные регулярные выражения отличаются от обычных тем, что многие символы имеют в них специальное значение, и не требуют экранирование их обратным слешем. Например: обычное выражение:
							<pre class="programlisting">/\([0-9]\+\.\)\{3\}/</pre>
							расширенное:
							<pre class="programlisting">/([0-9]+\.){3}/</pre>
							Это GNU расширение, и оно может быть непереносимо.
						</dd><dt><span class="term"><code class="option">`-s' `--separate'</code></span></dt><dd>
							По умолчанию, sed считает все переданные ей файлы одним большим файлом, и нумерует их строки последовательно(т.е. если в первом файле 100 строк, то первая строка второго файла будет иметь номер 101). С этим ключом sed нумерует строки каждого файла отдельно, потому первая строка каждого файла будет иметь номер 1, а последняя '$'.
						</dd><dt><span class="term"><code class="option">`-u' `--unbuffered'</code></span></dt><dd>
							Почти полное отключение буферизации как входного, так и выходного потока, размер буфера будет не более необходимого размера.
						</dd><dt><span class="term"><code class="option">`-e <span class="emphasis"><em>SCRIPT</em></span>' `--expression=<span class="emphasis"><em>SCRIPT</em></span>'</code></span></dt><dd>
							Добавляет в командную строку <span class="emphasis"><em>SCRIPT</em></span>, так-как первым параметром и так является скрипт, то этот ключ пригодится только при использовании ключа <code class="option">-f</code>, или если необходимо одной командой выполнить несколько скриптов.
						</dd><dt><span class="term"><code class="option">`-f <span class="emphasis"><em>SCRIPT-FILE</em></span>' `--file=<span class="emphasis"><em>SCRIPT-FILE</em></span>'</code></span></dt><dd><p>
								Заставит выполнить <span class="emphasis"><em>SCRIPT-FILE</em></span>, как последовательность команд sed.
							</p><p>
								Если ключи <code class="option">-f</code> и <code class="option">-e</code> не используются, скриптом считается первый параметр не являющийся ключом.
							</p><p>
								Файл "-" является стандартным потоком ввода, из него-же читается ввод, если никаких файлов не задано.
							</p></dd></dl></div><p>
			</p></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s03.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch06s02.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">AABS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Программирование в sed.</td></tr></table></div></body></html>
