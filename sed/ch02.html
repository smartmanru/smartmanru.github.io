<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Глава 2.</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="index.html" title="Краткий учебник по sed."><link rel="prev" href="ch01s03.html" title="Регулярные выражения."><link rel="next" href="ch02s02.html" title="Регулярные выражения изнутри."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Глава 2. </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s03.html">Пред.</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch02s02.html">След.</a></td></tr></table><hr></div><div class="chapter" title="Глава 2."><div class="titlepage"></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="section"><a href="ch02.html#id2510803"></a></span></dt><dd><dl><dt><span class="section"><a href="ch02.html#id2510805">Общие понятия.</a></span></dt><dt><span class="section"><a href="ch02.html#t01_1">Первые sed-скрипты.</a></span></dt><dt><span class="section"><a href="ch02.html#id2512418">Регулярные выражения(общие понятия).</a></span></dt><dt><span class="section"><a href="ch02.html#id2512448">Расширенные регулярные выражения.</a></span></dt><dt><span class="section"><a href="ch02.html#id2512508">Простые примеры.</a></span></dt><dt><span class="section"><a href="ch02.html#id2512792">Любой символ <span class="quote">&#171;<span class="quote">.</span>&#187;</span>.</a></span></dt><dt><span class="section"><a href="ch02.html#id2512874">Вопросительный знак <span class="quote">&#171;<span class="quote">?</span>&#187;</span>.</a></span></dt><dt><span class="section"><a href="ch02.html#id2512910">Плюс (+) и его жадность.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513131">Символьные классы.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513204">Фигурные скобки {}.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513245">Скобки ().</a></span></dt><dt><span class="section"><a href="ch02.html#id2513313">Якоря.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513364">Границы.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513389">Другие специальные символы.</a></span></dt><dt><span class="section"><a href="ch02.html#id2513448">Заключение.</a></span></dt></dl></dd><dt><span class="section"><a href="ch02s02.html">Регулярные выражения изнутри.</a></span></dt><dd><dl><dt><span class="section"><a href="ch02s02.html#id2513662">Поиск символа.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2513730">Поиск шаблона из нескольких символов.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2513941">Замечание про кодировки.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2513993">Нечёткий поиск.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2514040">Повторения.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2514189">Поиск альтернатив.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2514221">Конкатенация.</a></span></dt><dt><span class="section"><a href="ch02s02.html#id2514257">Обратные ссылки.</a></span></dt></dl></dd><dt><span class="section"><a href="ch02s03.html">Производительность и быстродействие sed.</a></span></dt><dd><dl><dt><span class="section"><a href="ch02s03.html#id2514353"></a></span></dt><dt><span class="section"><a href="ch02s03.html#id2514440">Время выполнения sed-скриптов.</a></span></dt><dt><span class="section"><a href="ch02s03.html#id2514588">Время выполнения регулярных выражений в sed.</a></span></dt><dt><span class="section"><a href="ch02s03.html#id2514717">Оптимизация команды s.</a></span></dt><dt><span class="section"><a href="ch02s03.html#id2514756">Оптимизация команды x.</a></span></dt><dt><span class="section"><a href="ch02s03.html#id2514792">Оптимизация команд d и D.</a></span></dt></dl></dd><dt><span class="section"><a href="ch02s04.html">BUGS (Ошибки в sed).</a></span></dt><dd><dl><dt><span class="section"><a href="ch02s04.html#id2515135">Вступление (Эта программа работает криво! Что делать?)</a></span></dt><dt><span class="section"><a href="ch02s04.html#id2515230">Команда N и последняя строка.</a></span></dt><dt><span class="section"><a href="ch02s04.html#id2515291">Синтаксис регулярных выражений (проблемы с обратным слешем).</a></span></dt><dt><span class="section"><a href="ch02s04.html#id2515367">sed -i портит файлы "только для чтения"!</a></span></dt><dt><span class="section"><a href="ch02s04.html#id2515471">Выражение /[А-Я]/ не совпадает с буквами русского алфавита!, а команда s/.*// не стирает буфер!</a></span></dt></dl></dd><dt><span class="section"><a href="ch02s05.html">sed FAQ (ЧАВО)</a></span></dt><dd><dl><dt><span class="section"><a href="ch02s05.html#id2515963">Q. Почему меняется не все, а только первое совпадение в строке?</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516002">Q. Как инвертировать RE, например найти все строки, где НЕТ строки <span class="quote">&#171;<span class="quote">ABC</span>&#187;</span>?</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516049">Q. Почему выражение /.*XYZ/ работает не так, как мне хочется? (где тут не жадные выражения?)</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516078">Q. Почему не работает символьный класс [а-я]? Почему команда s/.*// не стирает все символы?</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516125">Q. Почему команда sed -i редактирует файлы "только для чтения"?</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516145">Q. Почему иногда срабатывает, а иногда не срабатывает команда перехода t?</a></span></dt><dt><span class="section"><a href="ch02s05.html#id2516172">Q. Как обработать несколько строк сразу?</a></span></dt></dl></dd><dt><span class="section"><a href="ch02s06.html">Что нового в версии 4.2 по сравнению с 4.1.5?</a></span></dt></dl></div><div class="section"><div class="titlepage"></div><div class="section" title="Общие понятия."><div class="titlepage"><div><div><h4 class="title"><a name="id2510805"></a><a name="ch1"></a>Общие понятия.</h4></div></div></div><p>
				sed обрабатывает поток последовательно, строчка за строчкой, начиная с первой и кончая последней (конечно если в sed-скрипте не указано иного, например можно обрабатывать только первые строки, и завершить обработку после выполнения какого-нибудь условия), обычно каждая строка обрабатывается отдельно, в три этапа.
				</p><div class="important" title="Важно" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Важно</h3>
					Нижеприведённая схема в дальнейшем будет часто упоминаться, к примеру "на первом этапе обработки строки" как раз и обозначает - первый этап из этой схемы.
				</div><p>
				</p><div class="procedure" title="Процедура 2.1. Обработка текста утилитой sed."><a name="id2510840"></a><p class="title"><b>Процедура 2.1. Обработка текста утилитой sed.</b></p><ol class="procedure" type="1"><li class="step" title="Шаг 1"><p>Загрузка строки из потока.</p><p>
							На этом этапе строка загружается в буфер.  Буфером называется выделенная sed область памяти, размер которой не ограничен (для GNU версии sed, ну конечно на практике размер ограничен объёмом оперативной, и swap-памяти).
							</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
								Здесь и далее речь идёт только о GNU версии sed.  В некоторых других версиях имеются ограничения.
							</div><p>

							Загрузка заканчивается после чтения из потока символа новой строки (\n), или после завершения потока.  При этом символ новой строки хотя и читается из потока, однако не пишется в буфер.
						</p></li><li class="step" title="Шаг 2"><p><a name="e2"></a>Обработка строки.</p><p>На этом этапе выполняется sed-скрипт, при этом содержимое буфера обычно изменяется.  sed-скрипт состоит из особых sed-команд, каждая из которых представляет собой одну из букв латинского алфавита.  Как обычно, малые и БОЛЬШИЕ буквы различаются: <span class="command"><strong>n</strong></span> и <span class="command"><strong>N</strong></span> это разные команды.  Проще всего записывать sed-команды в командной строке, сразу после sed и её <code class="option">ключей</code>, например:</p><p>
							</p><pre class="programlisting">sed -n 'p;p;p'</pre><p>
							Для разделения команд используется точка с запятой (;).
							</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
								Если вы пишете скрипты прямо после команды, то всегда заключайте их в одиночные 'кавычки', дело в том, что только в этом случае оболочка не будет обрабатывать эти скрипты, в некоторых случаях допустимо использовать двойные кавычки, например если вы хотите внести внутрь скрипта shell-переменную, однако при этом будьте внимательны: shell попытается раскрыть многие служебные символы в вашем скрипте.
							</div><p>
							</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
								Если внутри скрипта вам необходимо использовать символ одиночной кавычки, то вы можете воспользоваться её шестнадцатеричным представлением: <span class="quote">&#171;<span class="quote">\x27</span>&#187;</span>.
							</div><p>
						</p><p>
							Команды sed могут изменить содержимое буфера, но кроме того, как и в других языках программирования, в sed-скриптах можно применять команды условных и безусловных переходов (<a class="link" href="ch05.html#btT"><span class="command"><strong>b</strong></span>, <span class="command"><strong>t</strong></span>, и <span class="command"><strong>T</strong></span></a>), имеются также команды прерывания работы (<span class="command"><strong>q</strong></span> и <span class="command"><strong>Q</strong></span>).  Некоторые команды воздействуют не только на этап обработки строки, но и на другие этапы, кроме того, внутри скрипта можно ввести ещё одну или несколько строк из входного потока (как на первом этапе).
							</p><div class="important" title="Важно" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Важно</h3>
								Нужно понимать, что sed работает с потоком, а не с файлом, она просматривает строки только последовательно, с начала и до конца.  Потому невозможно прочитать десятую строку после двадцатой - если в этом есть необходимость, следует сохранить десятую строку во время её обработки.  Так-же невозможно узнать, что данная строка является например предпоследней, не смотря на то, что вполне можно определить номер строки от начала потока.  Можно выяснить, что данная строка является последней, но только в момент её обработки.
							</div><p>
						</p><p>
							Перед (почти)любой командой sed вы можете поставить адресное выражение, в таком случае, команда выполнится тогда, и только тогда, когда адресное выражение истинно.  В качестве адресного выражения можно использовать
							</p><div class="variablelist"><dl><dt><span class="term">Номер строки</span></dt><dd>Тогда команда выполнится только для той строки, чей номер указан</dd><dt><span class="term">Диапазон номеров строк</span></dt><dd>Команда выполнится для всех строк из указанного диапазона(диапазон указывается через запятую, вместо второго числа допустимо указывать `$', этот символ обозначает последнюю строку.</dd><dt><span class="term">Регулярное выражение</span></dt><dd><p>
											Команда выполнится только если в буфере найдётся данное RE.
											</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
												Здесь и далее, сокращение RE расшифровывается как "регулярное выражение".
											</div><p>
										</p></dd><dt><span class="term">Комбинированный диапазон.</span></dt><dd><p>Можно создать и более сложное условие, к примеру от заданного RE, и до строки $ (до конца).  Или от первого RE до второго (включительно).
											</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
												Строки в sed нумеруются с единицы.  Сначала производится поиск строки, в которой есть совпадение с первым адресом диапазона, для этой строки выполняется команда.  Начиная со следующей строки производится поиск второго адреса диапазона.  Однако, для первой строки такое поведение можно изменить: если записать не `1,RE', а `0,RE', то регулярное выражение будет проверятся так-же и в первой строке.
											</div><p>
										</p></dd></dl></div><p>
						</p><p>
							</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
								Если вы хотите, что-бы одно адресное выражение действовало сразу не несколько команд, тогда заключите эти команды в {фигурные скобки}.
								<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
									Допустимы вложенные блоки, кроме того, допустимо внутри блока использовать адресные выражения в т.ч. и для вложенных блоков.
								</div></div><p>
						</p><p>
							Кроме написания скрипта сразу после команды, вы можете записать его в файл, для выполнения такого файла можно использовать опцию <code class="option">-f</code>, например:
							</p><pre class="programlisting">$ sed -f my_script.sed test_file.txt</pre><p>
							Эта команда выполнит sed-скрипт <code class="filename">my_script.sed</code> для файла <code class="filename">test_file.txt</code>.  Кроме того, используя sha-bang
							</p><pre class="programlisting">#!/bin/sed -f</pre><p>
							вы можете заставить исполнять ваши скрипты оболочку, например, если вы дописали в ваш скрипт в первую строку этот sha-bang, и кроме того у вас есть право выполнения этого скрипта, то прошлый пример можно выполнить так:
							</p><pre class="programlisting">$ ./my_script.sed test_file.txt</pre><p>
						</p><p>
							</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
								Первое время, я-бы рекомендовал записывать в файлы все sed-скрипты из тех, в которых более одной команды.  Во первых их понять намного проще, во вторых они таким образом сохраняются, и в третьих их намного удобнее редактировать.  Кроме того, в sed-файлах вы можете использовать любые кавычки.  Следует так-же учесть, что некоторые команды необходимо записывать последними в строке, что часто невозможно, если строка одна.  И наконец, в файле вы можете использовать комментарии, которые позволят вам быстро приспособить уже готовый скрипт для нового применения.
							</div><p>
						</p></li><li class="step" title="Шаг 3"><p><a name="e3"></a>Вывод буфера</p><p>
							После завершения работы скрипта sed выводит содержимое буфера в выходной поток.  Однако, это далеко не всегда необходимо, если вам это не нужно, воспользуйтесь опцией <code class="option">-n</code>, которая блокирует вывод буфера.  Кроме того, на этом же этапе происходит вывод и некоторой другой информации, если в скрипте выполнились команды <span class="command"><strong>a</strong></span>, <span class="command"><strong>c</strong></span>, и/или <span class="command"><strong>i</strong></span>.  Эти команды тоже выводят информацию в выходной поток, но не во время исполнения, а в этом этапе.  Существуют три команды (<span class="command"><strong>d</strong></span>, <span class="command"><strong>D</strong></span> и <span class="command"><strong>Q</strong></span>), которые так-же подавляют вывод буфера на этом этапе.
						</p></li></ol></div><p>
			</p></div><div class="section" title="Первые sed-скрипты."><div class="titlepage"><div><div><h4 class="title"><a name="t01_1"></a>Первые sed-скрипты.</h4></div></div></div><p>
				Для начала изучения <span class="command"><strong>sed</strong></span> нам потребуется какой-нибудь простой текст, например этот:
				<a name="test_txt"></a></p><div class="example"><a name="id2511617"></a><p class="title"><b>Пример 2.1. Текст используемый для проверки скриптов.</b></p><div class="example-contents"><a class="ulink" href="examples/test.txt" target="_top">test.txt</a><pre class="programlisting">В чём отличие Linux от Windows?

Идеологические отличия

Отличия огромны. Достаточно сказать, что Linux всё-таки надо рассматривать как один из
диалектов операционной системы UNIX, в то время как Windows является оригинальной
разработкой компании Microsoft и начиналась как надстройка над DOS. Таким образом всё что
появилось в Windows спустя годы после выхода в свет: многозадачность, сетевые протоколы и
т.д., в Linux присутствовало практически изначально. Многие вещи были просто портированны
(перенесены) в Linux из UNIX. Многие вещи, которые есть в Linux недоступны в Windows до сих
пор. Например, вы можете оценить многозадачность запустив в Windows и Linux копирование
файлов на дискету. В то время как в Windows до сих пор работать с чем-то ещё становится
просто невозможно, Linux ведёт себя так, как будто запись вообще не идёт - он не замечает
этот процесс. Если Windows изначально строилась как средство улучшенного взаимодействия с
пользователем и не может работать без графического интерфейса, Linux вполне может обходится
без привычных окон, мышек и всего остально антуража, тем самым экономя память и снижая
требования к ресурсам машины при использовании Linux в качестве сервера.

Windows имеет редакции Server (Сервер) и Workstation (Рабочая станция), но в Linux всё не
так. Устанавливая Linux вы получаете полный набор программного обеспечения и можете
использовать эту операционную систему и как сервер и как рабочую станцию. Вам
предоставляется полная свобода выбора, без всяких кодов и ключей и только от вас зависит как
вы будете использовать ваш Linux: хоть в качестве сервера на предприятии, где вы работает,
хоть дома в качестве рабочей машины или вообще на ноутбуке.</pre></div></div><p><br class="example-break">
			</p><p>
				Такой вот коротенький текстик.  Как обычно, примеры кодов и текстов я буду набирать моноширным шрифтом, что-бы все буквы были одинаковыми.  Что-бы создать тестовый файл, сначала скопируйте в буфер этот текст, а затем в каком-нибудь эмуляторе терминала (в командной строке, но только не в той, что вызывается по CTRL+ALT+Fn) Наберите:
				</p><pre class="screen">$ cat &gt; test.txt</pre><p>
				После чего, можно вставлять буфер, как? Зависит от терминала, обычно работает CTRL+INS, может сработает левая или средняя кнопка мыши, а может в меню есть нужный пункт, после вставки нажмите CTRL+D, для указания того, что файл завершён.  Кроме того, можно воспользоваться gvim'ом, либо любым другим текстовым редактором.
			</p><p>
				Теперь можно написать первый <span class="command"><strong>sed</strong></span>-скрипт:
				</p><pre class="screen">$ sed '' test.txt</pre><p>
				Этот скрипт просто выводит на экран терминала наш тестовый файл.  Это не слишком интересно, точно так-же работает та-же команда <span class="command"><strong>cat</strong></span>.  Этот примитивный пример говорит о многом: во-первых, две одиночные кавычки - это сам скрипт, между кавычками ничего нет, потому скрипт ничего не делает - не меняет никакой строчке в потоке.
				</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
					Я всегда использую одиночные кавычки, кроме некоторых особых случаев, это делается для того, что-бы не путать ни себя, ни компьютер: если таких кавычек не поставить, то сначала оболочка попытается обработать наш скрипт, а уж потом, когда получится полная ерунда, оболочка отдаст эту ерунду <span class="command"><strong>sed</strong></span> - если это и будет работать, то не правильно.  Хуже всего то, что иногда скрипт будет работать <span class="emphasis"><em>не всегда правильно</em></span>, что совсем уж по маздаевски...
				</div><p>
				Во-вторых, обратите внимание: сначала идёт скрипт, а после него идут файлы.
			</p><p>
				Теперь немного изменим наш "скрипт", заставим <span class="command"><strong>sed</strong></span> поменять все слова "Windows" на "Must Die", для этого нам понадобится <span class="command"><strong>sed</strong></span>-команда <span class="command"><strong>s</strong></span>, эта команда ищет в строке нужную одну строку, и заменяет её на другую:
				</p><pre class="screen">$ sed 's/Windows/Must Die/' test.txt
В чём отличие Linux от Must Die?

Идеологические отличия

Отличия огромны. Достаточно сказать, что Linux всё-таки надо рассматривать как один из
диалектов операционной системы UNIX, в то время как Must Die является оригинальной
разработкой компании Microsoft и начиналась как надстройка над DOS. Таким образом всё что
появилось в Must Die спустя годы после выхода в свет: многозадачность, сетевые протоколы и
т.д., в Linux присутствовало практически изначально. Многие вещи были просто портированы
(перенесены) в Linux из UNIX. Многие вещи, которые есть в Linux недоступны в Must Die до сих
пор. Например, вы можете оценить многозадачность запустив в Must Die и Linux копирование
файлов на дискету. В то время как в Must Die до сих пор работать с чем-то ещё становится
просто невозможно, Linux ведёт себя так, как будто запись вообще не идёт - он не замечает
этот процесс. Если Must Die изначально строилась как средство улучшенного взаимодействия с
пользователем и не может работать без графического интерфейса, Linux вполне может обходится
без привычных окон, мышек и всего остально антуража, тем самым экономя память и снижая
требования к ресурсам машины при использовании Linux в качестве сервера.

Must Die имеет редакции Server (Сервер) и Workstation (Рабочая станция), но в Linux всё не
так. Устанавливая Linux вы получаете полный набор программного обеспечения и можете
использовать эту операционную систему и как сервер и как рабочую станцию. Вам
предоставляется полная свобода выбора, без всяких кодов и ключей и только от вас зависит как
вы будете использовать ваш Linux: хоть в качестве сервера на предприятии, где вы работает,
хоть дома в качестве рабочей машины или вообще на ноутбуке.</pre><p>
				Ага, сработало!
			</p><p><a name="first_g"></a>
				Но не всё так радужно, если мы попробуем поменять "Linux" на "TRUE OS" нас ждёт разочарование:
				</p><div class="figure"><a name="id2507965"></a><p class="title"><b>Рисунок 2.1. Поиск 'Linux'</b></p><div class="figure-contents"><div><img src="img/snapshot15.png" alt="Поиск 'Linux'"></div></div></div><p><br class="figure-break">
				Не все слова "Linux" заменяются, некоторые остаются без изменений.  Дело в том, что <span class="command"><strong>sed</strong></span> по умолчанию заменяет только первое найденное слово...  Исправить это просто: достаточно в конце команды <span class="command"><strong>s</strong></span> добавить <span class="emphasis"><em>модификатор g</em></span> (команда - это не только буква s, но и то что идёт в слешах: слово для поиска и слово для замены).
				</p><pre class="screen">sed 's/Linux/TRUE OS/g' test.txt</pre><p>
			</p><p>
				Модификатор <span class="command"><strong>g</strong></span> позволяет заменять все совпадения. Имеются цифровые модификаторы, которые позволяют заменить лишь некоторые вхождения:
				</p><pre class="screen">echo "aaaaaaa" | sed 's/a/A/3'
aaAaaaa</pre><p>
				Меняется только третья буква <span class="quote">&#171;<span class="quote">a</span>&#187;</span>.
			</p><p>
				Цифровой модификатор можно комбинировать с модификатором <span class="command"><strong>g</strong></span>:
				</p><pre class="screen">echo "aaaaaaa" | sed 's/a/A/3g'
aaAAAAA</pre><p>
				Как видите, меняется третья, и все последующие буквы. Т.о. модификатор <span class="command"><strong>g</strong></span> заставляет sed продолжать замены до тех пор, пока строка не кончится; а цифровой модификатор говорит о том, с какого совпадения мы начнём замены. Не надо думать, что модификатор <span class="command"><strong>g</strong></span> сильно замедлит работу, sed в любом случае просматривает всю строку, даже если она уже сделала единственную замену (безусловно, на сами замены время тратится. Кроме того, уходит время на сдвиг хвоста, после заменяемой части, если длинна заменяемой и заменяющей части не совпадают. При массовых заменах хвост приходится двигать множество раз, что может сильно замедлить выполнение программы).
			</p><p>
				Кроме модификатора <span class="command"><strong>g</strong></span> так-же имеются модификатор <span class="command"><strong>i</strong></span>, который приведёт к тому, что <span class="command"><strong>sed</strong></span> не будет различать малые и большие буквы (в прошлом примере будет заменено слово lINUX, а так-же LiNuX, и все прочие); Многие команды sed дублируются в модификаторах. К примеру существует команда <span class="command"><strong>w</strong></span> для записи в файл. Так же есть и модификатор <span class="command"><strong>w</strong></span> с точно таким-же функционалом. Кроме того, имеются и другие модификаторы, которые мы рассмотрим несколько позже.
			</p></div><div class="section" title="Регулярные выражения(общие понятия)."><div class="titlepage"><div><div><h4 class="title"><a name="id2512418"></a>Регулярные выражения(общие понятия).</h4></div></div></div><p>
				На самом деле, <span class="command"><strong>sed</strong></span> ищет вовсе не слова, а <span class="emphasis"><em>Регулярные выражения</em></span>.  Регулярным выражением называется строка, в которой некоторые символы имеют специальное значение.  Если обычный символ просто ищется в строке, то спец-символ задаёт особые правила для поиска.
			</p></div><div class="section" title="Расширенные регулярные выражения."><div class="titlepage"><div><div><h4 class="title"><a name="id2512448"></a>Расширенные регулярные выражения.</h4></div></div></div><p>
				Я обычно использую не простые, а <span class="emphasis"><em>расширенные</em></span> регулярные выражения(<span class="emphasis"><em>ERE</em></span>), ИМХО они более наглядные.  Для их использования необходимо использовать <span class="command"><strong>sed</strong></span> с ключом <code class="option">-r</code>.  На самом деле это одно и то-же, отличие только в форме записи.  Примеры:
			</p><p>
				Обычное регулярное выражение:
				</p><pre class="programlisting">/\(.\+\)\{3\}/</pre><p>
				Расширенное выражение:
				</p><pre class="programlisting">/(.+){3}/</pre><p>
				Как видите, расширенные выражения часто намного проще и короче.  Впрочем, так это далеко не всегда, если мы используем спец-символы редко, то удобнее применять обычные выражения, в которых многие спец-символы не требуют экранирования обратным слешем.
			</p></div><div class="section" title="Простые примеры."><div class="titlepage"><div><div><h4 class="title"><a name="id2512508"></a>Простые примеры.</h4></div></div></div><p>
				Далее примеры совсем простые, потому мне достаточно всего одной строки, потому я буду передавать в <span class="command"><strong>sed</strong></span> строку командой <span class="command"><strong>echo</strong></span>, вот к примеру, эта команда поменяет первую букву D на z:
				</p><pre class="screen">$ echo "ABCDEEEEDG" | sed -r 's/D/z/'
ABCzEEEEDG</pre><p>
				Чаще всего встречается регулярное выражение <span class="quote">&#171;<span class="quote">.*</span>&#187;</span>, оно состоит из двух спец-символов:
				</p><div class="variablelist"><dl><dt><span class="term"> <span class="quote">&#171;<span class="quote">.</span>&#187;</span> (точка)</span></dt><dd>Означает - какой угодно символ, лишь-бы был хоть какой-нибудь.</dd><dt><span class="term">*</span></dt><dd>Означает - прошлый символ может повторятся любое количество раз, в том числе и вовсе отсутствовать.</dd></dl></div><p>
				В целом это выражение читается так: <span class="emphasis"><em>Любой символ повторяется сколько угодно раз</em></span>. С таким шаблоном совпадёт любая строка, в том числе и пустая.
				</p><pre class="screen">$ echo "ABCDEEEEDG" | sed -r 's/.*/z/'
z</pre><p>
				Вот более сложный пример со спец-символом:
				</p><pre class="screen">echo "ABCDEEEEDG" | sed -r 's/DE*/z/'
ABCzDG</pre><p>
				Регулярные выражения следует читать слева-направо, потому как именно так они и просматриваются командой <span class="command"><strong>sed</strong></span>.  
				Это выражение означает: <span class="emphasis"><em>Найти букву D, за которой идёт буква E, которая повторяется любое число раз.</em></span> 
				Тут видно что во-первых, спец-символ <span class="quote">&#171;<span class="quote">*</span>&#187;</span> действует только на один обычный символ(на букву E в данном случае), и во-вторых, видна <span class="emphasis"><em>жадность</em></span> звёздочки, она захватила не "любое" количество E, а всё что смогла.  
				В <span class="command"><strong>sed</strong></span> все модификаторы ведут себя точно так-же, и нет никакой возможности изменить это поведение, это очень полезно для ускорения работы наших скриптов. На самом деле наша строка делится на четыре части:
				</p><div class="variablelist"><dl><dt><span class="term">"ABC"</span></dt><dd>которая не подходит под шаблон /DE*/</dd><dt><span class="term">"DEEEE"</span></dt><dd>которая подходит под шаблон, причём подходит пятью способами: "D", "DE", "DEE", "DEEE", и "DEEEE".</dd><dt><span class="term">"D"</span></dt><dd>, эта часть подходит одним способом.</dd><dt><span class="term">"G"</span></dt><dd>это не подходит.</dd></dl></div><p>
				Находится только первое совпадение в строке, причём это совпадение берётся с максимально большим числом повторений (если спец-символ повторений допускает любое число совпадений). Конечно, модификатор `g' позволяет найти и заменить все совпадения.
				</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3><p>
						Ещё раз повторю: <span class="quote">&#171;<span class="quote">*</span>&#187;</span> означает - <span class="emphasis"><em>любое</em></span> число повторений. 
						В том числе и ноль. 
						Т.е. под регулярное выражение /E*/ попадают и пустые строки тоже, и любые строки, в которых есть пустые строки. К примеру строка "ABC" - в ней регулярное выражение /E*/ можно найти ЧЕТЫРЕ раза:
						</p><pre class="screen">$ echo "ABC" | sed 's/E*/z/g'
zAzBzCz</pre><p>
						Как видите, найдено ровно 4 совпадения, при этом, в данной строке вообще нет символа <span class="quote">&#171;<span class="quote">E</span>&#187;</span>.
					</p><p>
					Всё потому-что, как я уже ранее писал - совпадение, это место <span class="emphasis"><em>между</em></span> символами. 
					В строке <span class="quote">&#171;<span class="quote">ABC</span>&#187;</span> имеется 3 символа, и четыре места между символами, именно на эти 4 места и меняется RE /E*/.
					</p></div><p>
				</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
					Обычно этого не нужно. Потому в большинстве случаев следует использовать <span class="emphasis"><em>квантификатор</em></span><span class="command"><strong>+</strong></span>, он находит <span class="emphasis"><em>то, что ожидается</em></span>. Во многих примерах (в т.ч. даже и в info sed (см. ниже) часто всё равно используется звёздочка (*) вместо плюса (+) - это связано с ленью - используя обычные (не расширенные) регулярные выражения, нам придётся экранировать плюс, т.е. писать /E\+/, что намного сложнее чем /E*/.
				</div><p>
			</p></div><div class="section" title="Любой символ &#171;.&#187;."><div class="titlepage"><div><div><h4 class="title"><a name="id2512792"></a>Любой символ <span class="quote">&#171;<span class="quote">.</span>&#187;</span>.</h4></div></div></div><p>
				Вот следующий пример:
				</p><pre class="screen">echo "ABCDEEEEDG" | sed -r 's/D./z/g'
ABCzEEEz</pre><p>
				Тут ищутся все совпадения с шаблоном /D./, что означает: <span class="emphasis"><em>Буква D, после которой идёт один  любой символ</em></span>, здесь найдено 2 совпадения сразу: DE и DG.
				</p><div class="important" title="Важно" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Важно</h3><p>
						обращаю ваше внимание, что "любой символ" должен существовать, например в нашей строке есть `/G/', но нет `/G./', дело в том, что после единственной G нет вообще никаких символов.
					</p><p>
						Как всегда, речь идёт о символах, а вовсе не о байтах, например "Ф" в кодировке UTF-8 занимает 2 байта, однако sed считает эту букву одним символом. Далее будут неоднократно упоминаться "несимволы", например <span class="quote">&#171;<span class="quote">\xD1</span>&#187;</span> в кодировке UTF-8, данный <span class="emphasis"><em>несимвол</em></span> является первой половиной многих русских букв, и не совпадает (сам по себе) ни с одним регулярным выражением. К примеру RE .* совпадает с любой строкой символов, в том-числе и со строкой в которой нет символов, однако, даже это RE не совпадает со строкой, в которой есть хотя-бы один <span class="emphasis"><em>несимвол</em></span>. Будьте внимательны!
					</p></div><p>
			</p></div><div class="section" title="Вопросительный знак &#171;?&#187;."><div class="titlepage"><div><div><h4 class="title"><a name="id2512874"></a>Вопросительный знак <span class="quote">&#171;<span class="quote">?</span>&#187;</span>.</h4></div></div></div>
			Вопросительный знак означает 0 или одно повторение:
			<pre class="screen">$ echo "ABCDEEEEDG" | sed -r 's/DE?/z/g'
ABCzEEEzG</pre>
			найдено 2 совпадения: `DE' и `D'.
			<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
				Этот спец-символ (как и многие другие) надо экранировать слешем в обычных RE, и не нужно в ERE. Обратите внимание, я применил ключ <code class="option">-r</code> для того, что-бы не экранировать '?'.
			</div></div><div class="section" title="Плюс (+) и его жадность."><div class="titlepage"><div><div><h4 class="title"><a name="id2512910"></a>Плюс (+) и его жадность.</h4></div></div></div>
			Плюс работает в точности как `*', только тут символ который повторяется должен встречаться как минимум 1 раз.
			<pre class="screen">$ echo "ABCDEEEEDG" | sed -r 's/D*/z/g'
zAzBzCzEzEzEzEzGz

$ echo "ABCDEEEEDG" | sed -r 's/D+/z/g'
ABCzEEEEzG</pre>
			Такое дело, шаблон `/D*/' меняется на z перед любой буквой "не D", а если буква - D, то она меняется на z.  Т.о. например "A" у нас поменялось на "zA".  Шаблон `/D+/' меняет на z только подряд идущие буквы D.
			<div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3><p>
					Многие неправильно понимают жадность: например в выражении
					</p><pre class="programlisting">s/(.*)X.*/\1/</pre><p>
					очень часто ошибаются, считая, что захватится из "abc_def_ghi_C" только "abc", основная ошибка: непонимания того, что <span class="emphasis"><em>все</em></span> звёздочки(и прочие квантификаторы) жадные, и <span class="command"><strong>sed</strong></span> обрабатывает строки и выражения слева-направо.  Потому данное выражение захватит <span class="emphasis"><em>всё до последней буквы X</em></span>, а вовсе не до первой - первая звёздочка ТОЖЕ жадная.
				</p><p>
					Особенно опасны такие случаи:
					</p><pre class="screen">$ echo "___aaa" | sed -r 's/(.*)(a+)/\1~/'
___aa~</pre><p>
					Мы ясно видим <span class="quote">&#171;<span class="quote">aaa</span>&#187;</span> в конце строки, и ждём, что sed их заменит на <span class="quote">&#171;<span class="quote">~</span>&#187;</span>. Но происходит совсем другое. Дело в том, что sed вовсе ничего не угадывает и не подбирает, всё проще: в данном случае sed ищет два выражения в скобках <span class="emphasis"><em>одновременно</em></span>. Решение о том, где находится граница принимается в конце разбора. Точнее, после просмотра каждого символа граница сдвигается (новая граница затирает значение старой). По это причине результат работы будет следующий: оба выражения захватят столько символов, что-бы совпадение произошло. Однако, наши квантификаторы могут захватить и больше символов. 
				</p><p>
					Т.к. просмотр идёт слева-направо, то первый (левый) квантификатор захватит максимально возможное число символов. Второй захватит минимально-необходимое. Что мы и наблюдаем в этом примере: первый захватил 5 символов, а второй только один. Потому-что это плюс, была-бы звёздочка, то ей символов не досталось-бы вообще (для звёздочки "пусто" тоже совпадение).
				</p><p>
					Жадности посвящена большая часть этой книги. Действительно, как хорошо было например в php, что-бы захватить &lt;b&gt;произвольный текст с тегам внутри&lt;/b&gt; нам было достаточно использовать нежадную звёздочку. В sed таких нет, есть только жадная, а она захватывает весь текст, до последнего тега.
				</p><p>
					Кажется, что это серьёзный недостаток sed, но это не так: доказано, что для нежадных квантификаторов невозможен однопроходный алгоритм. В реальных скриптах практически невозможно предсказать, сколько-же проходов будет выполнятся, что приводит к тому, что скрипты отлично работающие при отладке, начинают тормозить и виснуть в реальных применениях. Мало того, злоумышленник может намертво повесить любой сайт, просто сформировав и отправив соответствующее сообщение/комментарий, такой, что-бы php скрипт совершил-бы огромное число проходов для каждого показа этого поста. (конечно, в реальной жизни такой быдлокод обычно всё-же отлавливается при тестировании. И тем не менее.).
				</p><p>
					Всё это невозможно в sed. Мало того, все ограничения жадности можно обойти, а часто и использовать жадность с пользой.
				</p></div></div><div class="section" title="Символьные классы."><div class="titlepage"><div><div><h4 class="title"><a name="id2513131"></a>Символьные классы.</h4></div></div></div>
			Можно задать метасимвол, который совпадает с несколькими символами, например:
			<pre class="screen">/[0123456789]/</pre>
			Совпадает с любой цифрой.  Допустимо указывать диапазон, тот-же класс можно записать так:
			<pre class="programlisting">/[0-9]/</pre>
			Это так-же любая цифра. Кроме того, можно задавать инверсию, например <span class="emphasis"><em>любой символ кроме цифр</em></span><pre class="programlisting">/[^0-9]/</pre><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
				Отрицание в символьном классе можно использовать для борьбы с жадностью: к примеру, для выдирания ссылки из HTML выражение /&lt;a href="(.*)"&gt;/ не подходит. Для исправления ситуации точку внутри круглых скобок достаточно заменить на класс <span class="emphasis"><em>любой символ кроме кавычки</em></span>: /&lt;a href="([^"]*)"&gt;/ в силу того, что внутри ссылок кавычек не бывает.
			</div>
			Таким образом, десятичное целое число со знаком можно записать так:
			<pre class="programlisting">/[-+]?[0-9]+/</pre>
			теперь запишу это по-русски: <span class="emphasis"><em>символ плюс или минус, которого может и не быть, а затем идёт несколько (хотя-бы один) символ не меньший нуля, и не больший девяти.</em></span></div><div class="section" title="Фигурные скобки {}."><div class="titlepage"><div><div><h4 class="title"><a name="id2513204"></a>Фигурные скобки {}.</h4></div></div></div>
			Фигурные скобки служат для задания числа повторений, к примеру <pre class="programlisting">/Q{7}/</pre>
			ищет в строке 7 букв Q подряд.  Можно задать диапазон, например
			<pre class="programlisting">/Q{3,9}/</pre>
			ищет от 3х до девяти букв Q, как и при применении остальных <span class="emphasis"><em>квантификаторов</em></span>, захватывается максимально возможное число символов.  Диапазон можно задать частично,
			<pre class="programlisting">/Q{1,}/</pre>
			эквивалентно
			<pre class="programlisting">/Q+/</pre></div><div class="section" title="Скобки ()."><div class="titlepage"><div><div><h4 class="title"><a name="id2513245"></a>Скобки ().</h4></div></div></div>
			Часть выражения можно заключить в скобки `(' `)', и тогда эта часть образует <span class="emphasis"><em>подвыражение</em></span>.  Подвыражения используются для ссылок, к примеру, команда
			<pre class="programlisting">s/.*([-+]?[0-9]+).*/\1/</pre>
			выделит из строки последнее целое десятичное число со знаком.
			<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
				это выражение содержит ошибку, какую?  И что-же в действительности будет выделено?
			</div>
			Ссылки можно использовать так-же и для задания повторений, к примеру
			<pre class="programlisting">s/(\S+\s+){3}//</pre>
			сотрёт первые три поля (полем здесь считается последовательность из нескольких не пробельных символов, после которых идут несколько пробельных).  Но самое важное применение скобок - поиск одинаковых подстрок, например, это выражение найдёт 2 одинаковых символа:
			<pre class="programlisting">/(.).*\1/</pre><a name="t02_1"></a>
			А это выражение находит только одинаковые строки, разделённые символом `\n':
			<pre class="programlisting">/^(.*)\n\1$/</pre></div><div class="section" title="Якоря."><div class="titlepage"><div><div><h4 class="title"><a name="id2513313"></a>Якоря.</h4></div></div></div><p>
				символы `^' и `$' означаю начало и конец буфера <span class="command"><strong>sed</strong></span> соответственно. Напомню, позицией совпадения в sed считается позиция между символами, потому, $ это позиция между последним символом и концом строки. Если символов вообще нет, то $ совпадает с ^.
			</p><p>
				Имеются ещё два якоря: <span class="quote">&#171;<span class="quote">\`</span>&#187;</span> и <span class="quote">&#171;<span class="quote">\'</span>&#187;</span>. Так же как и предыдущие, эти якоря задают начало и конец буфера sed. Различие между ними проявляется тогда, когда в буфере несколько строк. Мы рассмотрим их <a class="link" href="ch04s07.html#multiline">ниже</a>.
			</p></div><div class="section" title="Границы."><div class="titlepage"><div><div><h4 class="title"><a name="id2513364"></a>Границы.</h4></div></div></div>
			Кроме якорей, sed различает также границы между словом и не словом. У слова есть левая <span class="quote">&#171;<span class="quote">\&lt;</span>&#187;</span> и правая <span class="quote">&#171;<span class="quote">\&gt;</span>&#187;</span>. Имеется также граница, совпадающая с любой из предыдущих границ <span class="quote">&#171;<span class="quote">\b</span>&#187;</span>.
		</div><div class="section" title="Другие специальные символы."><div class="titlepage"><div><div><h4 class="title"><a name="id2513389"></a>Другие специальные символы.</h4></div></div></div>
			Многие экранированные символы в sed имеют специальное значение: например <span class="quote">&#171;<span class="quote">\s</span>&#187;</span> совпадает с любым пробельным символом (пробел, табуляция, перевод строки и возврат каретки). Любой непробельный символ записывается так: <span class="quote">&#171;<span class="quote">\S</span>&#187;</span>. Имеется символ <span class="quote">&#171;<span class="quote">\w</span>&#187;</span> совпадающий с любой буквой и с <span class="quote">&#171;<span class="quote">_</span>&#187;</span>. Это очень важный символ для русских - у нас применяются множество кодировок, и во многих символы разбросаны непонятным образом. Небуква записывается <span class="quote">&#171;<span class="quote">\W</span>&#187;</span>. Можно также задать символ его числовым кодом, например <span class="quote">&#171;<span class="quote">\x59</span>&#187;</span> эквивалентно <span class="quote">&#171;<span class="quote">Y</span>&#187;</span>.
		</div><div class="section" title="Заключение."><div class="titlepage"><div><div><h4 class="title"><a name="id2513448"></a>Заключение.</h4></div></div></div><p>
				В в заключение этой главы я хочу отметить, что написал я тут так мало вовсе не потому, что тема эта такая незначительная, нет!  Просто про регулярные выражения и мною и без меня написано уже слишком много, повторять мне не хочется, в вашей ОС есть множество документации по RE, и её всегда можно найти даже без интернета, если у вас есть даже самый поганый выход в сеть, вы всегда сможете найти то-же самое ещё и по-русски!  Регулярные выражения страшны и непонятны только первое время, уверяю вас, уже через недельку активного использования, вы не только станете их понимать, но и даже почувствуете <span class="emphasis"><em>красоту</em></span> некоторых формул!
			</p><p>
				Удачи!
			</p><p>
				Чуть выше был пример с ошибкой. В чём-же заключается ошибка? Давайте попробуем:
				</p><pre class="screen">$ echo "ABC-234XYZ+17sss" | sed -r 's/.*([-+]?[0-9]+).*/\1/'
7</pre><p>
				Видно, что наше RE захватило всего-лишь последнюю <span class="emphasis"><em>цифру</em></span>, а не число, как ожидалось. Это не баг, а фича. Далее подробно будет рассказано, почему так, и как добиться ожидаемого поведения. Сейчас только замечу, что выражения с квантификаторами sed делит на части, и ищет их все в строке, например здесь выражение делится на 4 части:
			</p><p>
				/.*/
			</p><p>
				/[-+]?/
			</p><p>
				/[0-9]+/
			</p><p>
				/.*/
			</p><p>
				Совпадение (а значит и замена) будет тогда, и только тогда, когда будут найдены все четыре части. Причём каждая часть ищется независимо и параллельно одна от другой. Причём каждое выражение захватывает сколько сможет. Выражение, которое стоит вначале, захватывает больше всех. Вот и в нашем случае, /.*/ пожрало все символы, кроме одной семёрки - одну семёрку ей пришлось оставить, т.к. выражение /[0-9]+/ совпадает только лишь с одним символом(или с несколькими, но не с пустой строкой), и если-бы звёздочка пожрала-бы и семёрку, то совпадения не было-бы вообще.
			</p><p>
				А вот <span class="emphasis"><em>+ (плюс)</em></span> от 17и был успешно пожран первой звёздочкой, она может это себе позволить, по той причине, что выражение /[+-]?/ может довольствоваться ничем. Вот оно ничто и получило. А именно место между `1' и `7'.
			</p></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s03.html">Пред.</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch02s02.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Регулярные выражения. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Регулярные выражения изнутри.</td></tr></table></div></body></html>
