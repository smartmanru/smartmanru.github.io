<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Регулярные выражения изнутри.</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="ch02.html" title="Глава 2."><link rel="prev" href="ch02.html" title="Глава 2."><link rel="next" href="ch02s03.html" title="Производительность и быстродействие sed."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Регулярные выражения изнутри.</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02.html">Пред.</a> </td><th width="60%" align="center">Глава 2. </th><td width="20%" align="right"> <a accesskey="n" href="ch02s03.html">След.</a></td></tr></table><hr></div><div class="section" title="Регулярные выражения изнутри."><div class="titlepage"><div><div><h3 class="title"><a name="id2513644"></a>Регулярные выражения изнутри.</h3></div></div></div><p>
			Конечно многие сочтут лишним объяснения КАК работают регулярные выражения, но мне почему-то кажется, что 99% сложностей как раз и связано с непониманием принципа работы RE.  Потому я решил нелишним напомнить, как происходит разбор RE.
		</p><div class="section" title="Поиск символа."><div class="titlepage"><div><div><h4 class="title"><a name="id2513662"></a>Поиск символа.</h4></div></div></div><p>
				Рассмотрим простейшее регулярное выражение
				</p><pre class="programlisting">/A/</pre><p>
				Это выражение ищет в строке букву 'A'.  Реализация тривиальная:
				</p><div class="figure"><a name="id2513679"></a><p class="title"><b>Рисунок 2.2. Поиск символа 'A'</b></p><div class="figure-contents"><div><img src="img/p1.png" alt="Поиск символа 'A'"></div></div></div><p><br class="figure-break">
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Начнём с начала строки s, при этом позиция i у нас будет равна 0 (индексы отсчитываются от нуля).</li><li class="listitem">Проверяем очередной символ s[i] на равенство его нашему шаблону 'A'.</li><li class="listitem">В случае если s[i] == 'A', мы нашли совпадение, выход.</li><li class="listitem">Если совпадения нет, увеличиваем индекс, переходя к следующему символу.</li><li class="listitem">Проверяем, не закончилась-ли строка.</li><li class="listitem">Если символы ещё есть, переходим к п2.</li><li class="listitem">Иначе выходим, поиск не удачный.</li></ol></div><p>
			</p></div><div class="section" title="Поиск шаблона из нескольких символов."><div class="titlepage"><div><div><h4 class="title"><a name="id2513730"></a>Поиск шаблона из нескольких символов.</h4></div></div></div><p>
				Это всё прекрасно, однако что делать если шаблон более сложен? Например
				</p><pre class="programlisting">/ABC/</pre><p>
				Для этого можно просто немного изменить наш алгоритм: после нахождения 'A' мы проверяем следующие буквы, до тех пор, пока не найдём полное совпадение:
				</p><div class="figure"><a name="id2513755"></a><p class="title"><b>Рисунок 2.3. Поиск RE /ABC/</b></p><div class="figure-contents"><div><img src="img/p2.png" alt="Поиск RE /ABC/"></div></div></div><p><br class="figure-break">
				Это работает, но очень медленно: во первых мы часто будем просматривать один символ множество раз (особенно если в нашей строке много букв 'A'), кроме того, при каждом просмотре необходимо проверить, есть-ли ещё символы (проверка у нас есть, но она проверяет только наличие s[i], а вот есть-ли у нас s[i+1] и s[i+2] - неизвестно).  Что-бы это исправить, мы сделаем не одну, а три проверки:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Мы всегда проверяем является-ли символ буквой 'A'.</li><li class="listitem">Если прошлая буква была <span class="quote">&#171;<span class="quote">A</span>&#187;</span>, мы проверяем, не является-ли текущая буква буквой <span class="quote">&#171;<span class="quote">B</span>&#187;</span>.</li><li class="listitem">Если прошлая буква была <span class="quote">&#171;<span class="quote">B</span>&#187;</span>, а позапрошлая - 'A', мы проверяем, не является-ли текущая буква буквой 'C'.</li></ol></div><p>
				Нам понадобится пара временных переменных: e1, которая истинна если выполнился п1, а так-же e2, которая истинна если выполнился п2.  Первый пункт мы выполняем всегда, второй только при истинности e1, а третий - если истинно e2.  Если на третьем пункте условие выполнилось - шаблон найден.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					При этом следует учесть, что при проверке мы используем <span class="emphasis"><em>старые</em></span> значение e1 и e2, те, что вычислены для прошлой буквы.
				</div><p>
				Получается примерно следующая схема:
				</p><div class="figure"><a name="id2513849"></a><p class="title"><b>Рисунок 2.4. Поиск RE /ABC/</b></p><div class="figure-contents"><div><img src="img/p3.png" alt="Поиск RE /ABC/"></div></div></div><p><br class="figure-break">
				Тут я для единообразия добавил e0, которая всегда истинна.
			</p><p>
				Ну и где-же тут ускорение?  А ускорение тут в том, что за раз мы проверяем по одному условию, но наши процессоры умеют большее: мой например умеет проверять сразу 32 условия, т.к. он 32х битный (я выделил эту проверку в жёлтый прямоугольник).  
				По этой причине я могу все три (максимум 32) проверки сделать за одну операцию, только для каждой проверки мне понадобится таблица в 256 бит (по числу символов), например для буквы <span class="quote">&#171;<span class="quote">A</span>&#187;</span> моя таблица будет состоять из одних нулей, кроме A-ного символа (65го в ASCII), тогда мне просто надо будет вынуть из таблицы бит, номер которого совпадает с номером символа.  
				А раз я проверяю за раз по 32 условия, мне понадобится 32 таких таблицы, что составляет ровно 1 килобайт.  Весь этот набор таблиц я могу вычислить перед поиском, а потом использовать его в случае, если мне опять понадобится поиск по этому шаблону.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Этот метод называется SHIFT-AND, т.к. для реализации его достаточно всего двух команд CPU: сдвиг, а потом поразрядное <span class="command"><strong>И</strong></span>.  Сдвигаю я при этом набор своих временных переменных e0, e1, e2 ... e31.
				</div><p>
			</p></div><div class="section" title="Замечание про кодировки."><div class="titlepage"><div><div><h4 class="title"><a name="id2513941"></a>Замечание про кодировки.</h4></div></div></div><a name="utf8"></a><p>
				</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
					Тут предполагается, что в одном символе у нас 8 бит, т.е. любой символ укладывается в один байт. Это <span class="emphasis"><em>не так</em></span> для кодировки UTF-8 (в которой и работают сегодня большинство систем). По этой причине, утилите sed приходится создавать более громоздкие таблицы, и значит тратить намного больше времени на обработку RE. Именно по этой причине, скрипты sed работают в разы дольше, чем более примитивные утилиты.
					<div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
						Если вам нужно быстродействие, вы можете отключить поддержку UTF-8, или наоборот, включить её. Для этого нужно поменять следующие переменные shell:
						<pre class="programlisting">export LC_COLLATE=ru_RU.UTF-8
export LC_CTYPE=ru_RU.UTF-8</pre></div></div><p>
			</p></div><div class="section" title="Нечёткий поиск."><div class="titlepage"><div><div><h4 class="title"><a name="id2513993"></a>Нечёткий поиск.</h4></div></div></div><p>
				Кроме ускорения поиска, при таком методе я могу очень просто реализовать <span class="emphasis"><em>нечёткий поиск</em></span>: к примеру в таблицах для символов (тех, что в 256 бит) я могу помечать единицей не только A, B, и C, но и a, b, и c - это приведёт к тому, что мой шаблон будет работать и с малыми и с большими буквами, например так:
					</p><pre class="programlisting">/[Aa][Bb][Cc]/</pre><p>
					или вот так:
					</p><pre class="programlisting">/ABC/I</pre><p>
					(это верно для адресного выражения, для команды <span class="command"><strong>s</strong></span> нужно использовать <code class="option">модификатор i</code>).
			</p></div><div class="section" title="Повторения."><div class="titlepage"><div><div><h4 class="title"><a name="id2514040"></a>Повторения.</h4></div></div></div><p>
				В действительности, поиск происходит немного по другому: строка просматривается слева направо, но при нахождении поиск не прерывается, просто запоминается <span class="emphasis"><em>позиция начала совпадения</em></span>.  После чего просмотр продолжается в поисках завершения совпадения.  Для простых шаблонов это не играет никакой роли, ведь начало совпадения можно легко рассчитать когда совпадение будет полностью найдено.  Однако, даже в простых случаях следует учитывать тот факт, что поиск производится по всей строке, а не только до первого совпадения.  Именно по этой причине возможно применение числовых модификаторов команды s.  По умолчанию полагается модификатор 1, что приводит к запоминанию первого совпадения, кроме того, мы можем указать например модификатор 7, что приведёт к запоминанию именно седьмого совпадения (если оно произойдёт конечно).
				</p><div class="tip" title="Подсказка" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3>
					Кстати, у sed нет модификатора для нахождения <span class="emphasis"><em>последнего</em></span> совпадения, он просто не нужен: мы можем записать
					<pre class="programlisting">s/(.*)X/\1Y/</pre>
					Что приведёт к замене именно последней X на Y.
					<div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
						К сожалению, это срабатывает в том, и только в том случае, если выражение /X/ <span class="emphasis"><em>чётко совпадает</em></span>, к примеру оно не содержит неопределённых квантификаторов, например `*'. Если выражение /X/ содержит *, то первое выражение /.*/ захватывает максимум, а выражению /X/ остаётся лишь пустая строка. Наиболее просто это решается если /X/ состоит из одного символа, в этом случае вместо /.*/ мы можем записать /[^X]*/, и тогда мы добьёмся ожидаемого поведения нашей конструкции, к примеру, выделить ссылку в HTML тексте мы можем так:
						<pre class="programlisting">/&lt;a href="([^"]+)"[^&gt;]*&gt;/</pre></div></div><p>
			</p><p>
				Шаблоны с квантификаторами обрабатываются так-же:  сначала ищется первое совпадение, а потом поиск повторяется необходимое число раз.  К примеру /X{1,2}/ найдёт первое X и запомнит его позицию, а далее будет снова искать X, если он найдётся, то завершением совпадения считается окончание этого второго X (конечно X может быть любым подвыражением, а не только одиночным символом).  Если второе X не найдётся, окончанием будет служить позиция окончания первого X (эта позиция тоже запоминается, но если будет найдено второе X, то новая позиция завершения затирает старую).  Как видите, sed никогда не возвращается к уже просмотренным символам.
			</p></div><div class="section" title="Поиск альтернатив."><div class="titlepage"><div><div><h4 class="title"><a name="id2514189"></a>Поиск альтернатив.</h4></div></div></div><a name="alter"></a>
			Для поиска альтернатив применяется одновременный поиск сразу по двум (или более) шаблонам, к примеру, /X|Y/ сразу ищет и X и Y.  Такой механизм объясняет тот факт, что срабатывает та альтернатива, которая захватывает больше символов (в случае, если обе они подходят).  На самом деле срабатывают обе, однако концом совпадения будет являются более поздняя позиция.
		</div><div class="section" title="Конкатенация."><div class="titlepage"><div><div><h4 class="title"><a name="id2514221"></a>Конкатенация.</h4></div></div></div>
			На самом деле выражение /XY/ не слишком и просто: в том случае, если в подвыражениях X и/или Y применяются квантификаторы, поиск производится сразу по двум шаблонам, X и Y.  При этом началом совпадения считается X для случая когда конец совпадения X совпадает с началом совпадения Y.  А концом совпадения является конец совпадения Y.  Например уже упоминавшиеся RE /.*X/: тут поиск сразу производится как по /.*/, так и по /X/.  В этом случае, как всегда при применении квантификаторов, конец каждого найденного совпадения затирает прошлый конец совпадения, а окончательное решение производится после полного просмотра.  Именно по этому мы находим кусок строки от начала, и до последней X.
		</div><div class="section" title="Обратные ссылки."><div class="titlepage"><div><div><h4 class="title"><a name="id2514257"></a>Обратные ссылки.</h4></div></div></div>
			Обратные ссылки так-же обрабатываются за один проход, однако, подвыражения в круглых скобках обладают своими (кстати рекурсивными) наборами временных переменных (начало и конец совпадения).  Потому при поиске возможно сравнение ещё не просмотренного текста с каким-то из найденных совпадений.  Выражения вроде /(.*)\1/ работают, причём довольно быстро, несмотря на то, что при поиске в 2*N одинаковых символов находится ровно N совпадений, причём запоминается только последнее совпадение - ровно половина исходной строки.  К сожалению, при этом уже нельзя применить метод SHIFT-AND, и приходится проводить проверку по одному символу, сложность которой в подобных случаях пропорциональна квадрату N.  Конечно на практике это N у нас очень мало (1-50 символов в большинстве случаев).
		</div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02s03.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 2.  </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Производительность и быстродействие sed.</td></tr></table></div></body></html>
