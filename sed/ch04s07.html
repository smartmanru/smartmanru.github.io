<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Работа с несколькими строками одновременно (выравнивание текста).</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="ch04.html" title="Глава 4. Примеры скриптов."><link rel="prev" href="ch04s06.html" title="Использование внешних утилит."><link rel="next" href="ch04s08.html" title="Изменение регистра букв."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Работа с несколькими строками одновременно (выравнивание текста).</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s06.html">Пред.</a> </td><th width="60%" align="center">Глава 4. Примеры скриптов.</th><td width="20%" align="right"> <a accesskey="n" href="ch04s08.html">След.</a></td></tr></table><hr></div><div class="section" title="Работа с несколькими строками одновременно (выравнивание текста)."><div class="titlepage"><div><div><h3 class="title"><a name="id2521216"></a>Работа с несколькими строками одновременно (выравнивание текста).</h3></div></div></div><a name="t08"></a><div class="section" title="Использование команд N и D. (выравнивание по левому краю)"><div class="titlepage"><div><div><h4 class="title"><a name="id2521225"></a>Использование команд N и D. (выравнивание по левому краю)</h4></div></div></div><p>
				Вообще-то, в нормальном режиме <span class="command"><strong>sed</strong></span> обрабатывает строки по одной, однако, часто требуется обрабатывать несколько строк, давайте попробуем сэмулировать вимовское <span class="command"><strong>gqap</strong></span>, это выравнивание строк по левому краю, с шириной столбца не более N (кстати, для этого у sed есть <a class="link" href="ch05.html#cL">команда <span class="command"><strong>L</strong></span></a>).  Положим N == 40, и возьмём <a class="link" href="ch02.html#test_txt">наш текст</a>. Алгоритм видимо будет следующим:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">читаем строку</li><li class="listitem">(цикл)  Добавляем к строке ещё строки, пока строка не станет больше или равна N</li><li class="listitem">У нас сейчас в буфере много коротких строк, мы делаем из них одну длинную</li><li class="listitem">Теперь отрезаем от строки кусок, не более N, и выводим его.</li><li class="listitem">Удаляем этот кусок, и переходим к п2.</li></ol></div><p>
				Ну первый пункт <span class="command"><strong>sed</strong></span> сама сделает, за нами остальное.  Как видите, что-бы не усложнять я опустил тут выход из скрипта - понятно, что когда-то он закончится, нам нужно будет всего-лишь проверить корректность завершения, и в случае чего внести коррективы (тут надо быть внимательным, обычно и так работает, но вы должны проверить все точки, где возможен выход из скрипта).  Есть ещё одна проблема: мы проверяем длину в цикле, однако мы не всегда сможем корректно разрезать строку, проблема в том, что резать мы можем только по пробелам и переводам строки.  Если мы загрузим слишком длинную строку без пробелов, то мы не сможем её порезать.  Я попробую вставить склейку внутрь цикла, и проверять с учётом этого случая.
			</p><p>
				Сложности конечно возникают, вот как например посчитать длину строки?  Ну 	например /.{40}/ это ровно сорок символов,
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					На самом деле, это не <span class="emphasis"><em>ровно</em></span> 40 символов - это <span class="emphasis"><em>как минимум</em></span> сорок символов, хотя их может быть и больше.  Регулярное выражение найдёт 40 символов, однако в буфере при этом могут находится и другие символы.
				</div><p>
				я было написал /.{40}\S*/, это получилось сорок символов, за которыми может быть ещё сколько-то не пробельных символов, т.е. строка большая или равная N, а нам нужна меньшая или равная.  Что-ж, и такое выражение можно составить: /.{,40}\s/.  Это от 0 до 40 символов, за которыми стоит один пробельный символ.
			</p><p>
				Вот что получилось в итоге:
				</p><div class="example"><a name="id2521386"></a><p class="title"><b>Пример 4.5. Выравнивание по левому краю.</b></p><div class="example-contents"><a class="ulink" href="examples/gqap.sed" target="_top">gqap.sed</a><pre class="programlisting">#!/bin/sed -rf

:begin_loop
/.{40}/! {
	# если у нас ещё меньше чем 40 символов, то мы загрузим
	# ещё одну строчку
	N
	# если загруженная строчка пустая, то мы
	# выводим этот хвост и выходим(хвост короче 40), то-же происходит,
	# если строк больше нет.
	/\n$/ b
	# команда N добавила нам \n, меняем его на пробел
	s/\n/ /
	# продолжаем цикл
	b begin_loop
}
# в строке больше 40 символов - отрезаем хвост
# тут используется жадность квантификатора - он стремится захватить как
# можно более длинную строку
s/^(.{,40})\s/\1\n/
# если хвост отрезан, (точнее отделён \n), тогда переходим к печати.
t end_loop
	# особый случай - строка длиннее 40 символов, однако разрезать её нельзя.
	# попробуем отрезать хоть как-то, пускай у нас иные строчки будут слишком
	# длинные, но только те, которые никак не порезать
	s/^(\S+)\s/\1\n/

:end_loop
# печать. печатается только отрезанная строка до первого \n
P
# следующая команда вырезает только-что распечатанную строку,
# и переходит к метке begin_loop, без загрузки сл. строки
D
					</pre></div></div><p><br class="example-break">
				В этом скрипте только первая строка вводится как обычно, из скрипта нет обычного выхода, скрипт заканчивается на команде <span class="command"><strong>D</strong></span>, а эта команда вовсе не запускает новый цикл, и новая строка не грузится, дело в том, что эта команда примерно соответствует командам
				</p><pre class="programlisting">s/[^\n]*\n//
b begin_loop</pre><p>
				Т.е., удаляет из буфера первую строчку, а затем переходит к началу скрипта.  Скрипт завершает свою работу в другом месте, а именно в команде <span class="command"><strong>N</strong></span>, если входной поток кончился, то N ничего не вводит, а переходит к завершению цикла, где содержимое буфера выводится в выходной поток.
			</p></div><div class="section" title="Многострочный режим команды s."><div class="titlepage"><div><div><h4 class="title"><a name="id2521481"></a><span class="emphasis"><em>Многострочный</em></span> режим команды s.</h4></div></div></div><a name="multiline"></a><p>
				Команда <span class="command"><strong>s</strong></span> способна работать в особом, <span class="emphasis"><em>многострочном</em></span> режиме.  Попробуем создать текст из 4х строк:
				</p><pre class="screen">$ echo -e "A\nB\nC\nD"
A
B
C
D</pre><p>
				А теперь загрузим этот текст целиком в буфер:
				</p><pre class="screen">$ echo -e "A\nB\nC\nD" | sed -rn 'N;N;N;p'
A
B
C
D</pre><p>
				тут первая строка загружается автоматически, а потом к ней добавляется ещё 3, и то что получилось распечатывается.  Получается то-же самое.  Но если сменить все переводы строки на что-то другое, мы сразу увидим разницу:
				</p><pre class="screen">$ echo -e "A\nB\nC\nD" | sed -rn 'N;N;N;s/\n/~/g;p'
A~B~C~D</pre><p>
				Таким образом, у нас в буфере оказалось сразу 4 строки разделённые \n.  Попробуем найти начало строк:
				</p><pre class="screen">$ echo -e "A\nB\nC\nD" | sed -rn 'N;N;N;s/^/~/g;p'
~A
B
C
D</pre><p>
				Как видите, находится только начало первой строки, для того, что-бы найти начало всех строк как раз и нужен модификатор <code class="option">m</code> команды <span class="command"><strong>s</strong></span>:
				</p><pre class="screen">$ echo -e "A\nB\nC\nD" | sed -rn 'N;N;N;s/^/~/mg;p'
~A
~B
~C
~D</pre><p>
				С этим модификатором можно найти начало любой строки в буфере.  Кроме того, концы строк так-же можно найти с помощью символа <span class="quote">&#171;<span class="quote">$</span>&#187;</span>.  
				Для поиска начала первой строки служит прямая кавычка <span class="quote">&#171;<span class="quote">\`</span>&#187;</span>, а для поиска конца последней строки, в этом режиме применяется экранированная обратная <span class="quote">&#171;<span class="quote">\'</span>&#187;</span>.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Вот <a class="link" href="ch04s13.html#pconf">пример</a> использования модификатора <code class="option">m</code>.
				</div><p>
			</p></div><div class="section" title="Выравнивание текста (по другому)."><div class="titlepage"><div><div><h4 class="title"><a name="id2521606"></a>Выравнивание текста (по другому).</h4></div></div></div><p>
				<a class="link" href="ch04s07.html#t08">Выше</a> мы рассмотрели выравнивание по левому краю, тут нет ничего сложного, лишь бы строки были не длиннее некоторого предела.  Вообще говоря, выравнивание - это когда строка имеет фиксированную длину равную N, длинные строки обрезаются, а для коротких добавляются пробелы.  Разрезать мы разрезали, но пробелов не добавили - просто справа они подразумеваются, и выводить их не нужно.
			</p><a name="t09_1"></a></div><a name="ex_right"></a><div class="section" title="Выравнивание по правому краю."><div class="titlepage"><div><div><h4 class="title"><a name="id2521651"></a>Выравнивание по правому краю.</h4></div></div></div><p>
				Не очень сложно выровнять порезанный текст не по левому, а по правому краю: для этого надо просто добавить слева N-l пробелов, где l - длинна строки.  Именно так-бы я и сделал на C, но в <span class="command"><strong>sed</strong></span> своя специфика: у нас нет вычитания.  Что-ж, сделаем по другому - добавим слева 40 пробелов, а потом вырежем 40 последних символов (подразумевается, что справа у нас нет оконечных пробелов, если ваш текст такое содержит, то надо предварительно очистить его, например командой s/\s*$//, конечно это команда <span class="command"><strong>sed</strong></span>).
				</p><div class="example"><a name="id2521686"></a><p class="title"><b>Пример 4.6. Выравнивание по правому краю.</b></p><div class="example-contents"><a class="ulink" href="examples/right.sed" target="_top">right.sed</a><pre class="programlisting">#!/bin/sed -rf

1{
	# подготовка области удержания - создание строки
	# из 40 пробелов
	x
	# 10 пробелов
	s/.*/          /
	# а тут мы каждый пробел меняем на 4, итого - 40
	s/ /    /g
	x
}

# подгружаем пробелы и переносим их в начало строки
G
s/(.*)\n(.*)/\2\1/
# теперь берём последние 40 символов
s/.*(.{40})$/\1/</pre></div></div><p><br class="example-break">
				Перед выравниванием по правому краю надо выровнять по левому, что-бы все строки были не длиннее 40 символов.  Если текст длиннее - то лишние символы обрежутся.
			</p></div><div class="section" title="Выравнивание по центру."><div class="titlepage"><div><div><h4 class="title"><a name="id2521725"></a>Выравнивание по центру.</h4></div></div></div><p>
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					В info sed так-же есть похожий <a class="link" href="ch07.html#info_center">пример</a>.
				</div><p>
				Выровнять текст по центру сложнее - для этого нужно сначала добавить пробелов справа, что-бы все строки были строго из N символов, а затем половину правых пробелов перенести влево.  Сложность конечно в вычислении половины.  Но это довольно просто, если использовать жадность, и тот факт, что все символы (пробелы) одинаковые.  Ровно половину пробелов можно выделить так
				</p><pre class="programlisting">s/(.*)\1/\1/</pre><p>
				Звёздочка может вообще не захватывать символов, и это - допустимо, может так-же захватить 1 пробел, а \1 ещё один, может так-же 2 пробела, при этом \1 так-же захватит 2.  Но так-как звёздочка жадная - она захватит максимум - ровно половину.  А вот и сам скрипт:
				</p><div class="example"><a name="id2521780"></a><p class="title"><b>Пример 4.7. Выравнивание по центру.</b></p><div class="example-contents"><a class="ulink" href="examples/center.sed" target="_top">center.sed</a><pre class="programlisting">#!/bin/sed -rf

1{
	x
	s/.*/          /
	s/ /    /g
	x
}

G
s/(.{41}).*/\1/
s/(.*)\n(.*)\2/\2\1/
				</pre></div></div><p><br class="example-break">
			А если N-l нечётное?  А вы сами подумайте, почему в этом случае всё корректно работает ;)
			</p></div><div class="section" title="Выравнивание по левому и правому краю."><div class="titlepage"><div><div><h4 class="title"><a name="id2521806"></a>Выравнивание по левому и правому краю.</h4></div></div></div><p>
				Раз уж речь пошла о выравнивании, то нужно захватить и последний случай.  Что-бы выравнять строку по обоим краям, проще всего вставлять пробелы внутрь строки до тех пор, пока строка не станет в N символов.  Необходимо предусмотреть случай, когда строка последняя в абзаце, такие строки выравнивать не нужно.  Абзацем будем считать строки, которые оканчиваются пустой строкой.  Вот сам скрипт:
				<a name="lr"></a>
				</p><div class="example"><a name="id2521842"></a><p class="title"><b>Пример 4.8. Выравнивание по левому и правому краю.</b></p><div class="example-contents"><a class="ulink" href="examples/rl.sed" target="_top">rl.sed</a><pre class="programlisting">#!/bin/sed -rf

N
/\n$/ b
h
s/\n.*//
t begin_loop
	:begin_loop
	/.{40}/ b end_loop
	s/([^ ]) ([^ ])/\1  \2/
	t begin_loop
	s/([^ ])  ([^ ])/\1   \2/
	t begin_loop
	s/([^ ])   ([^ ])/\1    \2/
	t begin_loop

g
P
D

:end_loop
G
s/\n.*\n/\n/
P
D
					</pre></div></div><p><br class="example-break">
				Не так-уж и сложно, и даже работает (только предварительно нужно <a class="link" href="ch04s07.html#t08">выравнять текст по левому краю</a>).  Скрипт начинается с команды <span class="command"><strong>N</strong></span>, которая подгружает следующую строку.  Если эта строка пустая - мы выходим из скрипта, распечатывая обе строки (так-же мы выходим если строки нет).  Сохранив обе строки в области удержания, мы вырезаем следующую, и начинаем цикл выравнивания текущей.  Выравнивание довольно просто - мы ищем дырку из одного пробела между не пробельными символами, и меняем её на дырку из двух пробелов.  Как только одиночные дырки кончатся, мы меняем двойные, а затем и тройные.  Цикл завершится как только у нас будет ровно 40 символов.  Возможен так-же особый случай: у нас может не хватить дырок.  В этом случае мы восстанавливаем строки, и печатаем не выравненный вариант.
				</p><div class="figure"><a name="id2521909"></a><p class="title"><b>Рисунок 4.8. Выравнивание по левому и правому краю.</b></p><div class="figure-contents"><div><img src="img/snapshot16.png" alt="Выравнивание по левому и правому краю."></div></div></div><p><br class="figure-break">
			</p></div><div class="section" title="Разделение текста на предложения."><div class="titlepage"><div><div><h4 class="title"><a name="id2521922"></a>Разделение текста на предложения.</h4></div></div></div><p>
				Прежде чем разделять текст на предложения, следует определить само понятие "предложение". Я буду считать предложением любую часть текста, которая оканчивается на [.!?], причём после этого символа должен идти пробел или перевод строки. Кроме того, предложение завершается, если после него идёт пустая строка.
			</p><p>
				Перед разделением на предложения срежем пробелы в начале и в конце строки и удалим пустые строки.
			</p><p>
				Мы сделаем вложенный цикл: во внешнем неявном цикле мы будем резать строки отделяя предложения символом '\n', а затем печатая по одному предложению командой <span class="command"><strong>P</strong></span>, после чего распечатанное предложение мы сотрём командой <span class="command"><strong>D</strong></span>, которая и продолжит внешний цикл.
			</p><p>
				Во вложенном цикле мы будем клеить строчки, если предложение не завершено. Для загрузки следующей строки мы воспользуемся командой <span class="command"><strong>N</strong></span>, и проверим особый случай - пустая строка, которая так-же завершает предложение. После загрузки новой строки, мы заменим загруженный символ '\n' на пробел.
			</p><p>
				</p><div class="example"><a name="id2522003"></a><p class="title"><b>Пример 4.9. разделение на предложения.</b></p><div class="example-contents"><a class="ulink" href="examples/pspl.sed" target="_top">pspl.sed</a><pre class="programlisting">
#!/bin/sed -rf

# удаление пробелов в начале и в конце строки
s/^\s+//
s/\s+$//

/^$/ d

t start
	:start
	# поиск первого предложения
	s/([.!?])\s/\1\n/
	t print_p

	# если строка последняя, то печатаем и выходим
	$ b

	# грузим следующую строчку
	N
	# проверяем, не является-ли загруженная строка пустой
	s/\n\s*$//
	# мы загрузили пустую строку - значит прошлая строка это предложение
	t
	# предложение продолжается и в следующей строке, меняем перевод строки
	# на пробел
	s/\n/ /
	# этот переход всегда выполняется
	t start

:print_p
# печать найденного и отделённого предложения
P
D
					</pre></div></div><p><br class="example-break">
			</p></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s06.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s08.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Использование внешних утилит. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Изменение регистра букв.</td></tr></table></div></body></html>
