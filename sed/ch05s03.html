<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>AABS</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="ch05.html" title="Глава 5. Справочные материалы."><link rel="prev" href="ch05s02.html" title="Метасимволы и квантификаторы."><link rel="next" href="ch06.html" title="Глава 6. info sed. (русский перевод)."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">AABS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s02.html">Пред.</a> </td><th width="60%" align="center">Глава 5. Справочные материалы.</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">След.</a></td></tr></table><hr></div><div class="section" title="AABS"><div class="titlepage"><div><div><h3 class="title"><a name="id2530241"></a>AABS</h3></div></div></div><div class="section" title="Вступление."><div class="titlepage"><div><div><h4 class="title"><a name="id2530245"></a>Вступление.</h4></div></div></div><p>
				Утилита sed никогда не используется в одиночку, её использование очень тесно связано с использованием оболочки. Я использую bash, и потому про эту оболочку также стоит сказать несколько слов.
			</p><p>
				К счастью, про bash уже многое написано, вы можете почитать <span class="command"><strong>man bash</strong></span>, а если вам этого недостаточно, то и <span class="command"><strong>info bash</strong></span>. Кроме того, имеется Advanced Bash Scripting (сокращённо - ABS), в котором расписаны многие тонкие моменты кодинга на этом ЯП.
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Кстати, ABS доступно и в русском переводе. Время от времени я просматриваю этот перевод, и даже иногда отписываюсь о найденных ошибках и неточностях. К счастью, переводчики ABS очень внимательны, и никогда не позволяют себе разных вольностей, вроде тех, что позволяю себе я (например в моём переводе info sed полно совсем левых комментариев и откровенной отсебятины. А что делать? Ну читайте оригинал...). Конечно перед прочтением этого документа следует внимательно изучить и man bash и ABS, про многие вещи я просто не буду писать - ведь они и без меня уже подробно описаны.
				</div><p>
			</p><p>
				Тем не менее, даже в ABS некоторые моменты не раскрыты. Это и заставило меня написать данное руководство.
			</p></div><div class="section" title="Разбор строки утилитой bash."><div class="titlepage"><div><div><h4 class="title"><a name="id2530329"></a>Разбор строки утилитой bash.</h4></div></div></div><p>
				Прежде всего, стоит заметить, что утилита bash на самом деле обрабатывает текстовый поток. Причём построчно (как и sed), разбор каждой загруженной строки прост:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Прежде всего, строка делится на слова, т.е. на последовательности любых символов, в которых нет <span class="emphasis"><em>разделителей</em></span>. Разделители записаны в переменной $IFS, и доступны для редактирования. Конечно просто так просмотреть эту переменную невозможно - все разделители невидимы, однако мы можем воспользоваться командой hexdump:
						<pre class="programlisting">$ echo -e "$IFS" | hexdump -c
0000000      \t  \n  \n
0000004</pre>
						Эта команда вывела нам список разделителей - как видно, у меня установлено три разделителя, это пробел, табуляция и перевод строки (вообще-то переводов строки 2 шт, второй был добавлен командой echo).
						<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
							Можно так-же задавать слова и с разделителями - для этого нужно либо экранировать разделители обратным слешем ('\'), либо заключать слова в двойные или одиночные кавычки ('"' или ''') см. ниже.
						</div></li><li class="listitem">
						Т.о. у нас получается набор слов. Первое слово в строке считается <span class="emphasis"><em>командой</em></span>, и обрабатывается особым образом: во первых, bash проверяет, есть-ли такая команда в списке <span class="emphasis"><em>встроенных</em></span> команд. Если есть такая встроенная команда, то она выполняется, в противном случае, bash просматривает каталоги перечисленные в $PATH, в поисках нужного файла. Если данного слова нет, то работа bash прерывается с сообщением об ошибке.
						<div class="warning" title="Внимание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Внимание</h3>
							В отличие от OS Windows, в переменной $PATH нет пути к текущему каталогу. А если он и есть (как в Slackware для юзеров), он записан последним. Это связано с безопасностью - злоумышленник не сможет <span class="emphasis"><em>подменить</em></span> команду из числа системных. К примеру, злоумышленник мог-бы создать свой исполняемый файл <span class="command"><strong>su</strong></span>, который отправил-бы ему введённый нами пароль рута например на его (злоумышленника) адрес электронной почты, а затем выполнил-бы родную su. Это невозможно по той причине, что будет выполнена родная команда su, по той причине, что именно она лежит в одном из первых путей в $PATH.
							<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
								Кроме того, злоумышленник не сможет так-же выполнить и родную команду su в своём скрипте - дело в том, что su читает пароли исключительно с клавиатуры, и попытка подсунуть ей пароль как-то иначе приведёт только к ошибке.
							</div></div>
						Из-за того, что в $PATH нет нашего текущего каталога, нам приходится запускать наши скрипты с указанием пути, например так:
						<pre class="programlisting">./my_script</pre>
						Конечно при этом необходимо установить право исполнения для этого файла, командой
						<pre class="programlisting">chmod +x my_script</pre><div class="warning" title="Внимание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Внимание</h3><p>
								Следует учитывать, что файлы ВСЕГДА создаются со сброшенным правом исполнения. Это тоже связано с безопасностью: злоумышленник не сможет нас заставить выполнить свою команду, если мы только явно не пропишем право её исполнения.
							</p><p>
								Если вы хотите ещё большей защиты, то вы можете монтировать раздел /home с опцией noexec, это приведёт к тому, что НИКТО не сможет выполнить файлы в данном разделе (а создание файлов во всех прочих разделах запрещено. Конечно необходимо запретить создание исполняемых файлов в общедоступных директориях /tmp и /var/tmp).
							</p><p>
								Однако, не следует забывать, что любой пользователь может выполнить любой скрипт подсунув его как параметр утилите bash. Для этого права выполнения НЕ нужно. Достаточно права выполнения самой bash (которое всегда есть), и права чтения этого скрипта.
							</p></div></li></ol></div><p>
			</p></div><div class="section" title="Разбор остальных параметров."><div class="titlepage"><div><div><h4 class="title"><a name="id2530547"></a>Разбор остальных параметров.</h4></div></div></div><p>
				После разделения строки на слова, выполняется первое слово как команда. Все остальные слова считаются параметрами. Из bash скрипта к ним можно получить доступ с помощью конструкций $0, $1, $2 и т.д.. Все целиком можно получить конструкцией $@ (в эту конструкцию НЕ входит $0, т.е. имя самой команды).
			</p></div><div class="section" title="Глоббинг"><div class="titlepage"><div><div><h4 class="title"><a name="id2530567"></a>Глоббинг</h4></div></div></div><p>
				Однако, разбор командной строки вовсе не завершается после разделения её на слова. Если в некоторых словах имеются символы *, {, }, ?, [, и ], то это слово считается <span class="emphasis"><em>именем файла</em></span>.
			</p><div class="section" title="Звёздочка."><div class="titlepage"><div><div><h5 class="title"><a name="id2530589"></a>Звёздочка.</h5></div></div></div><p>
					Вместо звёздочки (*) подставляется любое количество любых файлов. К примеру, если у нас в текущем каталоге имеются файлы
				</p><p>
					1.html
				</p><p>
					2.html
				</p><p>
					3.html
				</p><p>
					То, команда <span class="command"><strong>xxx *.html</strong></span> получит не один параметр, а 3. Данная команда выполнится так-же, как если-бы мы явно записали <span class="command"><strong>xxx 1.html 2.html 3.html</strong></span>. Если файлов подходящих под шаблон нет, то команда получит сам шаблон в неизменном виде.
				</p><p>
					</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
						Следует учитывать, что расширение имени (глоббинг) выполняет вовсе не программа, а сама оболочка. Это позволяет использовать глоббинг например в своих sed-скриптах.
					</div><p>
				</p><p>
					Звёздочка раскрывает любые файлы, кроме скрытых (скрытыми файлами и каталогами считаются любые файлы, первым символом в которых стоит точка (.)). Для вывода скрытых файлов следует использовать следующее выражение: <span class="command"><strong>.*</strong></span>. Некоторые утилиты так-же позволяют обрабатывать скрытые файлы путём указания <code class="option">опций</code>. Например, утилита <span class="command"><strong>ls</strong></span> показывает скрытые файлы с <code class="option">опцией -a</code>.
				</p><p>
					Следует помнить про 2 скрытых подкаталога, которые присутствуют в любом каталоге - это ссылка на сам каталог '.', и ссылка на родительский каталог '..'. Если вы обрабатываете скрытые файлы, вам надо учитывать эти каталоги (для избежания зацикливания скрипта).
				</p><p>
					Если вам необходимо передать в свою программу все файлы, вам следует записать <span class="command"><strong>xxx .* *</strong></span> При этом первое выражение (.*) раскроется во все скрытые файлы и каталоги, а второе - будет заменено на все обычные файлы.
				</p><p>
					Конечно, если у вас нет в этом каталоге обычных файлов (скрытые файлы всегда есть, это '.' и '..'), то вторая звёздочка не раскроется, и будет передана утилите <span class="command"><strong>xxx</strong></span> без изменений. На что она может выругаться, типа <span class="quote">&#171;<span class="quote">Нет такого файла '*'</span>&#187;</span>.
				</p><p>
					</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
						В ОС Linux нет разницы между файлами и каталогами, точнее, каталоги являются обычными файлами. По этой причине не существует простого способа раскрыть только файлы (не каталоги), или только каталоги. Впрочем, часто это и не нужно - например вы хотите передать в свою утилиту только файлы с музыкой - нет ничего проще:
						<pre class="programlisting">xxx *.mp3</pre>
						Именно по этой причине, я и рекомендую задавать всем файлам осмысленные расширения - да, они не нужны для ОС (в отличие от M$-DOS), однако очень помогут нам.
					</div><p>
				</p><p>
					</p><div class="caution" title="Предостережение" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Предостережение</h3>
						Нужно отметить, что звёздочки раскрываются вовсе не в простой список файлов, а в <span class="emphasis"><em>отсортированный</em></span> список. Часто это очень важно. Кроме того, я хотел-бы отметить, что в некоторых случаях раскрытие звёздочки невозможно, по той причине, что файлов слишком много, и они не влезают в строку (ага. Её длинна ограничена). Самое печальное, что при этом НЕ выводится никаких сообщений об ошибках. Файлы просто тупо теряются.
					</div><p>
				</p></div><div class="section" title="Двойная звёздочка."><div class="titlepage"><div><div><h5 class="title"><a name="id2530792"></a>Двойная звёздочка.</h5></div></div></div><p>
					В отличие от одиночной звёздочки (которая раскрывается в список файлов), двойная звёздочка раскрывается в список каталогов. К примеру, <span class="command"><strong>xxx **/*.sed</strong></span> приведёт к тому, что в утилиту xxx передадутся имена всех sed-скриптов во всех подкаталогах текущего каталога. При этом sed-скрипты из текущего каталога НЕ будут переданы в эту утилиту.
				</p><p>
					Кроме того, файлы из подкаталогов в подкаталогах так-же не будут переданы. Действие двойной звёздочки аналогично команде <span class="command"><strong>find -maxdepth 2 -mindepth 2</strong></span>, только двойная звёздочка ещё и сортирует файлы и не показывает скрытые каталоги.
				</p></div><div class="section" title="Вопросительный знак (?)."><div class="titlepage"><div><div><h5 class="title"><a name="id2530843"></a>Вопросительный знак (?).</h5></div></div></div>
				Этот символ при глоббинге расширяется в любой символ. В отличие от звёздочки, символ должен быть единственным. Т.о., запись <span class="command"><strong>xxx ????</strong></span> передаст в утилиту xxx все файлы из 4х символов. При этом, также как и при использовании звёздочки, скрытые файлы не будут переданы.
			</div><div class="section" title="Символьные классы."><div class="titlepage"><div><div><h5 class="title"><a name="id2530868"></a>Символьные классы.</h5></div></div></div>
				Как и в RE, при глоббинге допустимо использовать символьные классы. Например, в Linux различается регистр букв, и что-бы найти все картинки приходится использовать такое выражение:
				<pre class="programlisting">xxx *.[jJ][pP][gG]</pre>
				оно совпадает и с файлами вроде 1.jpg, и с 1.JPG, т.е. является регистронезависимым. Диапазоны так-же допускаются, к примеру
				<pre class="programlisting">xxx *.[0-9]</pre>
				расширяется в любые файлы, которые имеют расширения из любой цифры.
				<div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					Хотя символьные классы и реализованы в глоббинге, но там нет других фичь обычных RE, потому нельзя например задать любое числовое расширение (несколько цифр после точки). Если это необходимо, то можно использовать следующие подходы:
					<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Записать явно все суффиксы, например, для файлов с номерами не больше 999 это можно сделать так:
							<pre class="programlisting">xxx *.[0-9] *.[0-9][0-9] *.[0-9][0-9][0-9]</pre></li><li class="listitem">
							Можно получить список файлов утилитой ls, и прогнать его затем через sed.
						</li><li class="listitem">
							Кроме того, можно воспользоваться утилитой find с ключом -regex.
						</li></ol></div></div></div><div class="section" title="Фигурные скобки {}."><div class="titlepage"><div><div><h5 class="title"><a name="id2530948"></a>Фигурные скобки {}.</h5></div></div></div>
				Эти скобки задают альтернативы при глоббинге, к примеру
				<pre class="programlisting">ls *.{info,txt,sed}</pre>
				выведет все файлы с расширением info, txt, и sed.
			</div></div><div class="section" title="Перенаправление в bash'е."><div class="titlepage"><div><div><h4 class="title"><a name="id2530965"></a>Перенаправление в bash'е.</h4></div></div></div><p>
				Команды в bash обычно принимают параметры из стандартного потока ввода (/dev/stdin) и отправляют результат своей работы в стандартный поток вывода (/dev/stdout).
			</p></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s02.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Метасимволы и квантификаторы. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Глава 6. info sed. (русский перевод).</td></tr></table></div></body></html>
