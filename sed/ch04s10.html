<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Парсинг HTML.</title><link rel="stylesheet" href="chs/default.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="Краткий учебник по sed."><link rel="up" href="ch04.html" title="Глава 4. Примеры скриптов."><link rel="prev" href="ch04s09.html" title="Ещё один подход к регулировке жадности."><link rel="next" href="ch04s11.html" title="Вырезание комментария в bash скрипте."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Парсинг HTML.</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s09.html">Пред.</a> </td><th width="60%" align="center">Глава 4. Примеры скриптов.</th><td width="20%" align="right"> <a accesskey="n" href="ch04s11.html">След.</a></td></tr></table><hr></div><div class="section" title="Парсинг HTML."><div class="titlepage"><div><div><h3 class="title"><a name="id2522793"></a>Парсинг HTML.</h3></div></div></div><div class="section" title="Зачем это надо, если есть прекрасный парсер XYZ?"><div class="titlepage"><div><div><h4 class="title"><a name="id2522798"></a>Зачем это надо, если есть прекрасный парсер XYZ?</h4></div></div></div><p>
				Ага. Есть. Вот только этот парсер надо ещё найти, скачать и поставить. Причём вместе с последней версией любимого ЯП автора этого парсера. Ладно, если-бы автор любит перл, перл везде есть. А если там какой-нибудь Ruby нужен? Или ещё что похуже...
			</p><p>
				Но это-то ладно, хуже другое - <span class="quote">&#171;<span class="quote">парсить хтмл</span>&#187;</span> это всего-лишь часть задачи - обычно нужно что-то совсем другое, а парсинг - только часть общей задачи. Например мне тут потребовалось написать скрипт, который гуляет по сайту и совершает там разные действия. <span class="quote">&#171;<span class="quote">Зайти на страничку</span>&#187;</span> это просто: достаточно использовать программу <span class="command"><strong>wget</strong></span>, она с лёгкостью скачает нужную страничку, и кроме того, может использовать авторизацию, и многое другое. Затем данную страничку можно просмотреть нашей любимой sed, и выполнить необходимые действия. Проблема в том, что страничка предназначена вовсе не для sed, а для браузера, который покажет её юзеру. Потому напрямую обрабатывать эту страничку очень проблематично. Основная беда в том, что строки в HTML файле не совпадают с единицами обработки - например теги могут занимать несколько строк, а так-же возможна ситуация, когда в одной строке несколько разных тегов.
			</p></div><div class="section" title="Первичная обработка HTML."><div class="titlepage"><div><div><h4 class="title"><a name="id2522878"></a>Первичная обработка HTML.</h4></div></div></div><p>
				Прежде всего следует переформатировать текст так, что-бы в одной строке был-бы только один тег. Либо тегов в строке не было-бы вовсе (для кусков собственно текста).
			</p><p>
				Похожая задача нам уже встречалась при <a class="link" href="ch04s07.html#t08">выравнивание текста</a> - там так-же нужно было резать и склеивать строки.
				</p><pre class="programlisting">
#!/bin/sed -rnf

# форматирование HTML, все теги собираются
# каждый в свою строку

# загрузка первой строки...
# удаление ведущих пробелов
s/^\s+//
/^&lt;/{
	 # данная строка начинается с тега
	:tag
	/&gt;/{
		s/^[^&gt;]*&gt;/\L&amp;\n/
		P
		D
	}
	# строка содержит не целый тег
	$ b error
	N
	s/\r?\n/ /
	b tag
}

/&lt;/{
	# строка не начинается с тега, но, однако, его содержит
	s/\s*&lt;/\n&lt;/
	P
	D
}

# проверяем наличие символа &gt; вне тегов
/&gt;/ b error

s/\s+$//
# проверяем, не является-ли строка пустой, и печатаем её
/^$/! p
b

:error
s/.*/\x1b[31;1mErorr in line '&amp;'\x1b[0m/p
q 77</pre><p>

			</p><p>
				Здесь у нас так-же вложенный цикл - во внешнем цикле мы отделяем и выводим строки, которые склеиваем в внутреннем цикле. Этот внутренний цикл начинается с метки tag и заканчивается командой b tag. 
				Склейка строк осуществляется командой <span class="command"><strong>N</strong></span>, после которой мы удаляем символ перевода строки. 
				Во многих текстах из сети строки переводятся не символом <span class="quote">&#171;<span class="quote">\n</span>&#187;</span>, а символами <span class="quote">&#171;<span class="quote">\r\n</span>&#187;</span> (так принято в маздае). 
				На самом деле, в HTML допускаются любые комбинации любых пробельных символов - все они заменяются на одиночный пробел. А символ <span class="quote">&#171;<span class="quote">\r</span>&#187;</span> вообще-то также является пробельным. 
				Именно по этой причине мы срезаем не /\n/, а /\r?\n/, что можно перевести как <span class="emphasis"><em>символ <span class="quote">&#171;<span class="quote">\n</span>&#187;</span> перед которым может стоять символ <span class="quote">&#171;<span class="quote">\r</span>&#187;</span></em></span>. 
				В других местах скрипта я так-же удаляю пробельные символы в конце строк, там-же удаляется и <span class="quote">&#171;<span class="quote">\r</span>&#187;</span>, для упрощения дальнейшего анализа.
			</p><p>
				Строка может начинаться с тега (с символа <span class="quote">&#171;<span class="quote">&lt;</span>&#187;</span>), а может и не начинаться. 
				Если строка не начинается с тега, но его содержит, то я отделяю то, что перед тегом символом <span class="quote">&#171;<span class="quote">\n</span>&#187;</span>, а затем вывожу эту башку и продолжаю анализ (командами <span class="command"><strong>P</strong></span> и <span class="command"><strong>D</strong></span>). 
				Если строка не содержит тегов, то я её просто печатаю.
			</p><p>
				Самый интересный случай: это если строка начинается с тега, с символа <span class="quote">&#171;<span class="quote">&lt;</span>&#187;</span>. 
				В этом случае мы прежде всего проверяем, есть-ли в строке символ <span class="quote">&#171;<span class="quote">&gt;</span>&#187;</span>, который закрывает теги. 
				Если в строке есть хотя-бы один такой символ - значит строка содержит закрытый хтмл-тег. Его нужно отделить и вывести, это делается так-же тремя командами: <span class="quote">&#171;<span class="quote">s</span>&#187;</span>, <span class="quote">&#171;<span class="quote">P</span>&#187;</span>, <span class="quote">&#171;<span class="quote">D</span>&#187;</span>. 
				Причём последняя ещё и предаёт управление в начала скрипта для продолжения анализа хвоста после тега.
			</p><p>
				В случае, когда тег не закрыт, приходится подгружать следующие строки, пока тег не будет полностью загружен.
			</p></div><div class="section" title="Вырезание комментариев, скриптов и стилей."><div class="titlepage"><div><div><h4 class="title"><a name="id2523097"></a>Вырезание комментариев, скриптов и стилей.</h4></div></div></div><p>
				К сожалению, вышеприведённый скрипт работает только в теории. В реальных текстах часто присутствуют комментарии, стили, и скрипты на других языках (обычно на JavaScript). В этих вставках часто попадаются символы &lt; и &gt;, которые приводят к ошибкам.
			</p><p>
				Логично собрать все эти вставки в одну строку, для упрощения дальнейшего анализа. Ну например так:</p><pre class="programlisting">
/^&lt;!--/{
	:comment
	# эта строка начинается с коментария
	# насколько я понимаю, в комментах можно всё, кроме --&gt;
	/--&gt;/{
		# строка так-же содержит завершение коменнта
		# убираем его
		:remove_substring
		s//&amp;\n/
		P
		D
	}
	# строка не содержит конца коммента, грузим след.
	# проверяем особый случай: незавершённый коммент
	$ b error
	N
	s/\r?\n/&lt;\\n&gt;/
	b comment
	}</pre><p>
			</p><p>
				Если строка содержит начало комментария, то я начинаю собирать все дальнейшие строчки в одну, учитывая тот факт, что комментарии мне так-же могут пригодится для дальнейшего анализа. При этом переводы строк я так-же сохраняю - я их изменяю на собственный тег &lt;\n&gt;. В некоторых случаях комментарии также важны для анализа.
			</p></div><div class="section" title="Проблемы с быстродействием."><div class="titlepage"><div><div><h4 class="title"><a name="id2523162"></a>Проблемы с быстродействием.</h4></div></div></div><p>
				В точности так-же как и с комментариями, можно расправится и со стилями и жабоскриптами - засунуть в одну строку, и передать для дальнейшего анализа.
			</p><p>
				Проблема в том, что это очень долго - например реальный файл с <a class="ulink" href="http://emule-rus.net" target="_top">форума</a> обрабатывается таким образом за 2.85 секунд - <span class="emphasis"><em>это неприемлемо!</em></span>. Связано это вот с чем: после загрузки каждой строки нам нужно проверить, не является-ли загруженный кусок окончанием данной строки. Для этого нам придётся просмотреть не только загруженную подстроку, но и все предыдущие (если мы ищем окончание комментария, стиля, или яваскрипта. <span class="quote">&#171;<span class="quote">Все</span>&#187;</span> в данном контексте означает <span class="quote">&#171;<span class="quote">все строки этого стиля/скрипта/коммента</span>&#187;</span>.).
			</p><p>
				Дело в том, что стили и скрипты можно вводить в HTML двумя способами, во первых отдельным файлом, который будет подгружаться браузером при необходимости (обычно браузер всегда и подгружает), либо напрямую вставляя в HTML. Конечно, для нас второй способ нафиг не нужен, однако, мы не в силах переписать все движки всех сайтов так, как это <span class="emphasis"><em>нам</em></span> было-бы удобнее...
			</p><p>
				Как всегда возможно несколько решений. Основное время у нас отнимает команда s/ЗАВЕРШЕНИЕ_СТИЛЯ_ИЛИ_СКРИПТА//, и что-бы её ускорить, нам нужно проводить поиск не по всему стилю/скрипту, а только по его последней строке. Для этого надо грузить строку командой <span class="command"><strong>n</strong></span>, которая затирает предыдущие строки, а что-бы сохранить стиль/скрипт нужно его добавлять в область удержания командой <span class="command"><strong>H</strong></span>.
			</p><p>
				Это общее решение. И именно его я-бы и и применял. Однако, изначально у нас была другая задача: мы хотели обрабатывать <span class="emphasis"><em>автономно</em></span> странички, без участия человека. Т.е. создать бота, который сам ползает по Сети. Но зачем нашему боту скрипты и стили? Зачем выполнять яваскрипт, единственная функциональность которого - выдать табличку <span class="quote">&#171;<span class="quote">Вы уверенны?</span>&#187;</span>? Это не нужно ни нам, ни нашему боту. Потому мы можем смело постирать все скрипты и стили, оставив вместо них просто
				</p><pre class="programlisting">&lt;style type="text/css"&gt;&lt;/style&gt;</pre><p>
				Ну типа - <span class="quote">&#171;<span class="quote">здесь был стиль.</span>&#187;</span>
				</p><div class="note" title="Замечание" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Замечание</h3>
					С этой оптимизацией скрипт выполняется не за 2.85 секунд, а за 0.14 - такое время примерно соответствует нулю - 0.14 секунд это меньше, чем погрешность измерения.
				</div><p>
			</p></div><div class="section" title="Готовый скрипт для парсинга HTML."><div class="titlepage"><div><div><h4 class="title"><a name="id2523320"></a>Готовый скрипт для парсинга HTML.</h4></div></div></div><div class="example"><a name="id2523325"></a><p class="title"><b>Пример 4.10. Скрипт для парсинга HTML (предварительная резка и склейка строк).</b></p><div class="example-contents"><a class="ulink" href="examples/fmt2_html.sed" target="_top">fmt2_html.sed</a></div></div><br class="example-break"></div><div class="section" title="Работа над ошибками."><div class="titlepage"><div><div><h4 class="title"><a name="id2523340"></a>Работа над ошибками.</h4></div></div></div><p>
				Как всегда, в реальной жизни возможны ошибки и неточности. Например наш скрипт может чего-то не понять в загруженном файле. Кроме того, возможен вариант, что веб-мастер будет использовать какие-то хитрые и неизвестные нам конструкции HTML. Если-бы наша программа была интерактивной, то нам было-бы достаточно просто вывести табличку <span class="quote">&#171;<span class="quote">Быдлокодерская страничка!</span>&#187;</span>, однако, у нас бот работающий автономно. Потому нам приходится действовать по другому.
			</p><p>
				Если документ для анализа слишком кривой, и обработка его невозможна, наш скрипт переходит к метке :error, в которой он во первых выводит раскрашенную ярко-красным проблемную строку, а во вторых прерывает скрипт с кодом 77. Скрипт, который вызвал данный скрипт может проверить код ошибки и предпринять какие-то меры для её устранения. Самое простое - отправить сообщение в журнал, и завершить работу.
			</p></div><div class="blockquote"><blockquote class="blockquote"><p>
		Вы можете обсудить этот документ на <a class="ulink" href="http://emulek.tk/forum/viewtopic.php?f=19&amp;t=5026" target="_top">форуме</a>. Текст предоставляется по лицензии <a class="ulink" href="http://www.gnu.org/licenses/fdl.html" target="_top">GNU Free Documentation License</a> (<a class="ulink" href="http://forum.lorcode.org/viewtopic.php?f=15&amp;t=30" target="_top">Перевод лицензии GFDL</a>).
	</p><p>
		Вы можете пожертвовать небольшую сумму яндекс-денег на счёт <span class="command"><strong>41001666004238</strong></span> для оплаты хостинга, интернета, и прочего. Это конечно добровольно, однако это намного улучшит данный документ (у меня будет больше времени для его улучшения). На самом деле, проект часто находится на грани закрытия, ибо никаких денег никогда не приносил, и приносить не будет. Вы можете мне помочь. Спасибо.
	</p></blockquote></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s09.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s11.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Ещё один подход к регулировке жадности. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Вырезание комментария в bash скрипте.</td></tr></table></div></body></html>
