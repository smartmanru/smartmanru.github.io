#!/bin/sh

# Это вроде как shell, но на самом деле, это 2 скрипта на sed.

sed -r '
# если в строке нет ни одной буквы - то нет и слов, исключаем
/\w/!d

# небуквы в конце строки удаляем
s/\W+$//

# вставка перевода строки и маркёра в дыры между словами
# дырка - это много небукв после правой границы слова
# правых границ столько-же сколько слов, но мы меняем
# не всё - после последней границы не может быть небукв
# мы их удалили прошлой командой
s/\>\W+/\na~/g

# вставка маркёра перед первым словом
s/^\W*/a~/
'  $@ |\
sed -rn '

G
# на эту строчку приходится основная нагрузка:
# первое подвыражение в скобках захватывает полностью анализируемое слово
# второе подвыражение расположено в начале базы до найденого совпадения
# третье - это старый номер в позиционной системе счисления, тут a означает 1,
# aa == 2, aaa == 3 ... b == 10, ba == 11, baa = 12 ... bbbaa == 32, dccbaaaa == 1214
# четвёртое подвыражение - это хвост, то, что расположено за совпадением
# в случае совпадения слово с номером убирается из базы, и записывается в начало,
# так-же к номеру добавляется a, т.о. счётчик увеличивается на 1
# кроме того, часто используемые слова группируются в начале базы для увеличения
# быстродействия.
s/^a~([^\n]+)(.*)\n([a-f]+)~\1\n(.*)/\3a~\1\2\n\4/
t old_word

# новое слово
h
# что-бы небыло очень скучно выводим новые слова в stderr
s/\n.*//
s/^a~//
w /dev/stderr
b ctrl_end

:old_word
# Старое слово, мы его нашли, и вытащили в начало базы
# и ещё добавили букву а в конец. Если букв a больше 9,
# нам следует сменить их на b, и т.д.
s/^([b-f]*)a{10}/\1b/; T done
s/^([c-f]*)b{10}/\1c/; T done
s/^([d-f]*)c{10}/\1d/; T done
s/^([ef]*)d{10}/\1e/; T done
s/^(f*)e{10}/\1f/; T done
s/^f{10}//
# максимум 999999 единиц - вполне хватит ИМХО
:done
x

:ctrl_end
$!b
#следующие команды выполняются в конце текста
s/.*/ ----- Найденные слова -----/p
x
# перевод позиционной системы счисления в обычную
:begin_convert
# проверяем, надо-ли ещё переводить?
/^[0-9 ]/ b end_convert

# сохраняем, что-бы не конвертить всю базу
h
s/~.*//
t lx_convert
:lx_convert
s/a{9}/9/; t dx_convert
s/a{8}/8/; t dx_convert
s/a{7}/7/; t dx_convert
s/a{6}/6/; t dx_convert
s/a{5}/5/; t dx_convert
s/a{4}/4/; t dx_convert
s/a{3}/3/; t dx_convert
s/a{2}/2/; t dx_convert
s/a/1/; t dx_convert
s/$/0/; t dx_convert
:dx_convert
y/bcdef/abcde/
s/[a-f]/\0/
t lx_convert
# теперь мы отконвертировали наш счётчик

# выравнивание: слева от числа добавляется 5 пробелов
s/^/     /
# затем берутся 6 последних символов
s/.*(......)/\1/

# теперь мы можем добавить базу
G

# ротация базы. первая запись переносится на последнее место
# кроме того, мы затираем позиционный счётчик.
s/([^\n]+)\n[a-f]+~([^\n]+\n)(.*)/\3\1 \2/
b begin_convert

:end_convert
p
'
